{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#about","title":"About","text":"<p>STAC is a metadata specification for spatial dataset. <code>stac_generator</code> is a CLI tool for building STAC compliant catalogs and collections from common spatial data extensions for raster, vector and point data.</p>"},{"location":"#install","title":"Install","text":"<p>To install the latest version of <code>stac_generator</code>, simply run </p> <pre><code>pip install stac_generator\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>In the following tutorial, we will use <code>stac_generator</code> to describe a combination of set of vector data. The vector data contains LGA data in geopackage format, soil exposure as a geojson, soil subgroup as a zip compressed shape file. The generated metadata is a STAC collection with each dataset as a STAC item. </p>"},{"location":"#creating-a-configuration-file","title":"Creating a configuration file","text":"<p>Some spatial data types like vector are self-describing with well-understood structure adhering to some specifications. Others like csv point data are not. As such, the <code>stac_generator</code> requires additional external metadata provided in the form of a configuration file. At the bear minimum, each entry in the configuration file must have an <code>id</code> field that corresponds to the <code>id</code> of the generated item, and a <code>location</code> field that describes where the raw data is stored. Each data type may have additional requirements for processing the raw data file. For more information, please visit the schema page for each extension in the navigation bar. </p> <p>For our example, we will use the following vector_config.json: </p> <pre><code>[\n    {\n        \"id\": \"LGA\",\n        \"location\": \"https://object-store.rc.nectar.org.au/v1/AUTH_9f063fd4ed28439487e49cddfb56d02d/TestData/Adelaide/vector/LGA_GPKG.gpkg\",\n        \"epsg\": 3857,\n        \"datetime\": null,\n        \"start_datetime\": \"2020-01-01T00:00:00Z\",\n        \"end_datetime\": \"2020-01-02T00:00:00Z\"\n    },\n    {\n        \"id\": \"SoilExposure\",\n        \"location\": \"https://object-store.rc.nectar.org.au/v1/AUTH_9f063fd4ed28439487e49cddfb56d02d/TestData/Adelaide/vector/SoilExposure_GeoJson.geojson\",\n        \"epsg\": 7844,\n        \"datetime\": null,\n        \"start_datetime\": \"2020-01-01T00:00:00Z\",\n        \"end_datetime\": \"2020-01-02T00:00:00Z\"\n    },\n    {\n        \"id\": \"SoilSubgroup\",\n        \"location\": \"https://object-store.rc.nectar.org.au/v1/AUTH_9f063fd4ed28439487e49cddfb56d02d/TestData/Adelaide/vector/SoilSubgroup_SHP.zip\",\n        \"epsg\": 1168,\n        \"datetime\": null,\n        \"start_datetime\": \"2020-01-01T00:00:00Z\",\n        \"end_datetime\": \"2020-01-02T00:00:00Z\"\n    }\n]\n</code></pre> <p>In this example, the raw data (shape/geojson/gpkg) files are stored in a remote location. If you have files stored locally, you can also set the <code>location</code> field to point to the raw data. </p> <p>Users can also use a csv for configuration. The equivalent config in csv format can be found here.</p>"},{"location":"#saving-the-stac-records","title":"Saving the STAC records","text":"<p>Once the configuration file is created, users can save the records to a local directory on disk, or to push to a STAC API endpoint. </p> <pre><code>stac_generator &lt;config_path&gt; --dst &lt;save_path&gt; --id &lt;collection_id&gt;\n</code></pre> <p>For instance, if I want to create the collection <code>vector_data</code> to <code>example/generated</code> with the <code>vector_config.json</code> config in the current directory, I can run the following: </p> <pre><code>stac_generator vector_config.json --dst example/generated --id vector_data\n</code></pre> <p>For saving to a remote API endpoint: </p> <pre><code>stac_generator vector_config.json --dst http://115.146.84.224:808 --id vector_data\n</code></pre>"},{"location":"generator/","title":"Generator","text":""},{"location":"generator/#stac_generator.base.generator.CollectionGenerator","title":"<code>CollectionGenerator</code>","text":"<p>CollectionGenerator class. User should not need to subclass this class unless greater control over how collection is generated from items is needed.</p>"},{"location":"generator/#stac_generator.base.generator.CollectionGenerator.__init__","title":"<code>__init__(collection_cfg, generators)</code>","text":"<p>CollectionGenerator - generate collection from generators attribute</p> <p>Parameters:</p> Name Type Description Default <code>collection_cfg</code> <code>StacCollectionConfig</code> <p>collection metadata</p> required <code>generators</code> <code>Sequence[ItemGenerator]</code> <p>sequence of ItemGenerator subclasses.</p> required"},{"location":"generator/#stac_generator.base.generator.CollectionGenerator.spatial_extent","title":"<code>spatial_extent(items)</code>  <code>staticmethod</code>","text":"<p>Extract a collection's spatial extent based on geometry information of its items</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Sequence[pystac.Item]</code> <p>a list of children items in the collection</p> required <p>Returns:</p> Type Description <code>pystac.SpatialExtent</code> <p>a bbox enveloping all items</p>"},{"location":"generator/#stac_generator.base.generator.CollectionGenerator.temporal_extent","title":"<code>temporal_extent(items)</code>  <code>staticmethod</code>","text":"<p>Extract a collection's temporal extent based on time information of its items</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Sequence[pystac.Item]</code> <p>a list of children items in the collection</p> required <p>Returns:</p> Type Description <code>pystac.TemporalExtent</code> <p>[start_time, end_time] enveloping all items</p>"},{"location":"generator/#stac_generator.base.generator.CollectionGenerator.create_collection","title":"<code>create_collection()</code>","text":"<p>Generate collection from all gathered items</p> <p>Spatial extent is the bounding box enclosing all items Temporal extent is the time interval enclosing temporal extent of all items. Note that this value is automatically calculated and provided temporal extent fields (start_datetime, end_datetime) at collection level will be ignored</p> <p>Returns:</p> Type Description <code>pystac.Collection</code> <p>generated collection</p>"},{"location":"generator/#stac_generator.base.generator.ItemGenerator","title":"<code>ItemGenerator</code>","text":"<p>               Bases: <code>abc.ABC</code>, <code>Generic[T]</code></p> <p>Base ItemGenerator object. Users should extend this class for handling different file extensions.</p>"},{"location":"generator/#stac_generator.base.generator.ItemGenerator.source_type","title":"<code>source_type: type[T]</code>  <code>instance-attribute</code>","text":"<p>SourceConfig subclass that contains information used for parsing the source file</p>"},{"location":"generator/#stac_generator.base.generator.ItemGenerator.__init__","title":"<code>__init__(configs)</code>","text":"<p>Base ItemGenerator object. Users should extend this class for handling different file extensions.</p> <p>Parameters:</p> Name Type Description Default <code>configs</code> <code>list[dict[str, Any]]</code> <p>source data configs - either from csv config or yaml/json</p> required"},{"location":"generator/#stac_generator.base.generator.ItemGenerator.create_item_from_config","title":"<code>create_item_from_config(source_cfg)</code>  <code>abstractmethod</code>","text":"<p>Abstract method that handles <code>pystac.Item</code> generation from the appropriate config</p>"},{"location":"generator/#stac_generator.base.generator.ItemGenerator.create_items","title":"<code>create_items()</code>","text":"<p>Generate STAC Items from <code>configs</code> metadata</p> <p>Returns:</p> Type Description <code>list[pystac.Item]</code> <p>list of generated STAC Item</p>"},{"location":"generator/#stac_generator.base.generator.VectorGenerator","title":"<code>VectorGenerator</code>","text":"<p>               Bases: <code>ItemGenerator[T]</code></p>"},{"location":"generator/#stac_generator.base.generator.VectorGenerator.geometry","title":"<code>geometry(df)</code>  <code>staticmethod</code>","text":"<p>Calculate the geometry from geopandas dataframe.</p> <p>If geopandas dataframe has only one item, the geometry will be that of the item. If geopandas dataframe has less than 10 items of the same type, the geometry will be the Multi version of the type. Note that MultiPoint will be unpacked into points for the 10 items limit. If there are more than 10 items of the same type or there are items of different types i.e. Point and LineString, the returned geometry will be the Polygon of the bounding box. Note that Point and MultiPoint are treated as the same type (so are type and its Multi version).</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>gpd.GeoDataFrame</code> <p>input dataframe</p> required"},{"location":"generator/#stac_generator.base.generator.VectorGenerator.temporal_extent","title":"<code>temporal_extent(df=None, time_col=None, datetime=None, start_datetime=None, end_datetime=None)</code>  <code>staticmethod</code>","text":"<p>Generate [start_datetime, end_datetime] property fields for a STAC Item</p> <p>If both df and time_col are provided, the temporal extent will be calculated as the min and max of time_col values in df, provided the values are of datetime type.</p> <p>If start_datetime and end_datetime are provided, return as is.</p> <p>If datetime is provided, return [datetime, datetime]</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>gpd.GeoDataFrame | None</code> <p>dataframe with a time column. defaults to None</p> <code>None</code> <code>time_col</code> <code>str | None</code> <p>time column in df, defaults to None</p> <code>None</code> <code>datetime</code> <code>pydatetime.datetime | None</code> <p>datetime value, defaults to None</p> <code>None</code> <code>start_datetime</code> <code>pydatetime.datetime | None</code> <p>start_datetime value, defaults to None</p> <code>None</code> <code>end_datetime</code> <code>pydatetime.datetime | None</code> <p>end_datetime value, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>TimeExtentT</code> <p>[start_datetime, end_datetime] information</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if both df and time_col are provided as argument, but time_col is not a valid column in df</p> <code>ValueError</code> <p>time_col does not have datetime type</p> <code>ValueError</code> <p>all parameters are None.</p>"},{"location":"generator/#stac_generator.base.generator.VectorGenerator.df_to_item","title":"<code>df_to_item(df, assets, source_cfg, properties, time_col=None, epsg=4326)</code>  <code>staticmethod</code>","text":"<p>Convert geopandas dataframe to pystac.Item</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>gpd.GeoDataFrame</code> <p>input dataframe</p> required <code>assets</code> <code>dict[str, pystac.Asset]</code> <p>source data asset_</p> required <code>source_cfg</code> <code>SourceConfig</code> <p>config</p> required <code>properties</code> <code>dict[str, Any]</code> <p>pystac Item properties</p> required <code>time_col</code> <code>str | None</code> <p>time_col if there are time information in the input df, defaults to None</p> <code>None</code> <code>epsg</code> <code>int</code> <p>epsg information, defaults to 4326</p> <code>4326</code> <p>Returns:</p> Type Description <code>pystac.Item</code> <p>generated pystac Item</p>"},{"location":"generator/#stac_generator.base.generator.StacSerialiser","title":"<code>StacSerialiser</code>","text":""},{"location":"generator/#stac_generator.base.generator.StacSerialiser.pre_serialisation_hook","title":"<code>pre_serialisation_hook(collection, href)</code>  <code>staticmethod</code>","text":"<p>Hook that can be overwritten to provide pre-serialisation functionality. By default, this normalises collection href and performs validation</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>pystac.Collection</code> <p>collection object</p> required <code>href</code> <code>str</code> <p>serialisation href</p> required"},{"location":"generator/#stac_generator.base.generator.StacSerialiser.to_json","title":"<code>to_json()</code>","text":"<p>Generate STAC Collection and save to disk as json files</p>"},{"location":"generator/#stac_generator.base.generator.StacSerialiser.to_api","title":"<code>to_api()</code>","text":"<p>_Generate STAC Collection and push to remote API. The API will first attempt to send a POST request which will be replaced with a PUT request if a 409 error is encountered</p>"},{"location":"schema/","title":"Schema","text":""},{"location":"schema/#stac_generator.base.schema.StacCommonMetadata","title":"<code>StacCommonMetadata</code>","text":"<p>               Bases: <code>_StacCommonMetaData</code></p> <p>Stac Common Metadata. Automatically sets datetime values to current datetime if neither datetime nor start_datetime and end_datetime are provided</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig","title":"<code>StacCollectionConfig</code>","text":"<p>               Bases: <code>StacCommonMetadata</code></p> <p>Contains parameters to pass to Collection constructor. Also contains other metadata</p> <p>This config provides additional information that can not be derived from source file, which includes Stac Common Metadata and other descriptive information such as the id of the new entity</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>Collection id</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.title","title":"<code>title: str = 'Auto-generated'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Collection title</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.description","title":"<code>description: str = 'Auto-generated Stac Collection'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Collection description</p>"},{"location":"schema/#stac_generator.base.schema.StacItemConfig","title":"<code>StacItemConfig</code>","text":"<p>               Bases: <code>StacCommonMetadata</code></p> <p>Contains parameters to pass to Item constructor.</p> <p>This config provides additional information that can not be derived from source file, which includes Stac Common Metadata and other descriptive information such as the id of the new entity</p>"},{"location":"schema/#stac_generator.base.schema.StacItemConfig.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>Item id - doubles as prefix if there are multiple items extracted from the source file</p>"},{"location":"schema/#stac_generator.base.schema.StacItemConfig.description","title":"<code>description: str = 'Auto-generated Stac Item'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Item description</p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig","title":"<code>SourceConfig</code>","text":"<p>               Bases: <code>StacItemConfig</code></p> <p>Base source config that should be subclassed for different file extensions.</p> <p>Source files contain raw spatial information (i.e. geotiff, shp, csv) from which some Stac metadata can be derived. SourceConfig describes:</p> <ul> <li>The access mechanisms for the source file: stored on local disk, or hosted somewhere behind an api endpoint. If the source file must be accessed through an endpoint, users can provide additional HTTP information that forms the HTTP request to the host server.</li> <li>Processing information that are unique for the source type. Users should inherit <code>SourceConfig</code> for file extensions currently unsupported.</li> <li>Additional Stac Metadata from <code>StacConfig</code></li> </ul>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.location","title":"<code>location: str</code>  <code>instance-attribute</code>","text":"<p>Asset's href.</p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.extension","title":"<code>extension: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Explicit file extension specification. If the file is stored behind an api endpoint, the field <code>extension</code> must be provided</p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.method","title":"<code>method: HTTPMethod | None = 'GET'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTPMethod to acquire the file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.params","title":"<code>params: QueryParamTypes | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query params for getting file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.headers","title":"<code>headers: HeaderTypes | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query headers for getting file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.cookies","title":"<code>cookies: CookieTypes | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query cookies for getting file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.content","title":"<code>content: RequestContent | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.data","title":"<code>data: RequestData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.json_body","title":"<code>json_body: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"utils/","title":"Utility","text":""},{"location":"utils/#stac_generator.base.utils.parse_href","title":"<code>parse_href(base_url, collection_id, item_id=None)</code>","text":"<p>Generate href for collection or item based on id</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>path to catalog.</p> required <code>collection_id</code> <code>str</code> <p>collection id</p> required <code>item_id</code> <code>str | None</code> <p>item id, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>uri to collection or item</p>"},{"location":"utils/#stac_generator.base.utils.href_is_stac_api_endpoint","title":"<code>href_is_stac_api_endpoint(href)</code>","text":"<p>Check if href points to a resource behind a stac api</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>path to resource</p> required <p>Returns:</p> Type Description <code>bool</code> <p>local or non-local</p>"},{"location":"utils/#stac_generator.base.utils.force_write_to_stac_api","title":"<code>force_write_to_stac_api(url, id, json)</code>","text":"<p>Force write a json object to a stac api endpoint. This function will try sending a POST request and if a 409 error is encountered, try sending a PUT request. Other exceptions if occured will be raised</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>path to stac resource for creation/update</p> required <code>json</code> <code>dict[str, Any]</code> <p>json object</p> required"},{"location":"extensions/csv/generator/","title":"Generator","text":""},{"location":"extensions/csv/generator/#stac_generator.csv.generator.CsvGenerator","title":"<code>CsvGenerator</code>","text":"<p>               Bases: <code>VectorGenerator[CsvConfig]</code></p> <p>ItemGenerator class that handles point data in csv format</p>"},{"location":"extensions/csv/generator/#stac_generator.csv.generator.CsvGenerator.create_item_from_config","title":"<code>create_item_from_config(source_cfg)</code>","text":"<p>Create item from source csv config</p> <p>Parameters:</p> Name Type Description Default <code>source_cfg</code> <code>CsvConfig</code> <p>config which contains csv metadata</p> required <p>Returns:</p> Type Description <code>pystac.Item</code> <p>stac metadata of the item described in source_cfg</p>"},{"location":"extensions/csv/generator/#stac_generator.csv.generator.read_csv","title":"<code>read_csv(src_path, X_coord, Y_coord, epsg, Z_coord=None, T_coord=None, date_format='ISO8601', columns=None)</code>","text":"<p>Read in csv from local disk</p> <p>Users must provide at the bare minimum the location of the csv, and the names of the columns to be treated as the X and Y coordinates. By default, will read in all columns in the csv. If columns and groupby columns are provided, will selectively read specified columns together with the coordinate columns (X, Y, T).</p> <p>Parameters:</p> Name Type Description Default <code>src_path</code> <code>str</code> <p>path to csv file</p> required <code>X_coord</code> <code>str</code> <p>name of X field</p> required <code>Y_coord</code> <code>str</code> <p>name of Y field</p> required <code>epsg</code> <code>int</code> <p>epsg code</p> required <code>Z_coord</code> <code>str | None</code> <p>name of Z field</p> <code>None</code> <code>T_coord</code> <code>str | None</code> <p>name of time field, defaults to None</p> <code>None</code> <code>date_format</code> <code>str</code> <p>format to pass to pandas to parse datetime, defaults to \"ISO8601\"</p> <code>'ISO8601'</code> <code>columns</code> <code>list[str] | list[ColumnInfo] | None</code> <p>band information, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>read dataframe</p>"},{"location":"extensions/csv/schema/","title":"Schema","text":""},{"location":"extensions/csv/schema/#stac_generator.csv.schema.ColumnInfo","title":"<code>ColumnInfo</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict description of Csv columns</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.ColumnInfo.name","title":"<code>name: Required[str]</code>  <code>instance-attribute</code>","text":"<p>Column name</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.ColumnInfo.description","title":"<code>description: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Column description</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.ColumnInfo.dtype","title":"<code>dtype: NotRequired[DTYPE]</code>  <code>instance-attribute</code>","text":"<p>Column data type</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.CsvExtension","title":"<code>CsvExtension</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Csv metadata required for parsing geospatial data from csv source.</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.CsvExtension.X","title":"<code>X: str</code>  <code>instance-attribute</code>","text":"<p>Column to be treated as longitude/X coordinate</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.CsvExtension.Y","title":"<code>Y: str</code>  <code>instance-attribute</code>","text":"<p>Column to be treated as latitude/Y coordinate</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.CsvExtension.epsg","title":"<code>epsg: int = 4326</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EPSG code</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.CsvExtension.Z","title":"<code>Z: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Column to be treated as altitude/Z coordinate</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.CsvExtension.T","title":"<code>T: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Column to be treated as time coordinate</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.CsvExtension.column_info","title":"<code>column_info: list[str] | list[ColumnInfo] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Description of attributes collected from the csv</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.CsvExtension.date_format","title":"<code>date_format: str = 'ISO8601'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Format to parse dates - will be used if T column is provided</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.CsvExtension.coerce_to_object","title":"<code>coerce_to_object(v)</code>  <code>classmethod</code>","text":"<p>Convert json serialised string of column info into matched object</p>"},{"location":"extensions/csv/schema/#stac_generator.csv.schema.CsvConfig","title":"<code>CsvConfig</code>","text":"<p>               Bases: <code>SourceConfig</code>, <code>CsvExtension</code></p> <p>Source config exteneded with CsvExtension fields</p>"},{"location":"extensions/vector/generator/","title":"Generator","text":""},{"location":"extensions/vector/generator/#stac_generator.vector.generator.VectorGenerator","title":"<code>VectorGenerator</code>","text":"<p>               Bases: <code>BaseVectorGenerator[VectorConfig]</code></p> <p>ItemGenerator class that handles vector data with common vector formats - i.e (shp, zipped shp, gpkg, geojson)</p>"},{"location":"extensions/vector/generator/#stac_generator.vector.generator.VectorGenerator.create_item_from_config","title":"<code>create_item_from_config(source_cfg)</code>","text":"<p>Create item from vector config</p> <p>Parameters:</p> Name Type Description Default <code>source_cfg</code> <code>VectorConfig</code> <p>config information</p> required <p>Returns:</p> Type Description <code>pystac.Item</code> <p>stac metadata of the file described by source_cfg</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if config epsg information is different from epsg information from vector file</p>"},{"location":"extensions/vector/generator/#stac_generator.vector.generator.extract_epsg","title":"<code>extract_epsg(crs)</code>","text":"<p>Extract epsg information from crs object. If epsg info can be extracted directly from crs, return that value. Otherwise, try to convert the crs info to WKT2 and extract EPSG using regex</p> <p>Note that this method may yield unreliable result</p> <p>Parameters:</p> Name Type Description Default <code>crs</code> <code>CRS</code> <p>crs object</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>epsg information</p>"},{"location":"extensions/vector/schema/","title":"Schema","text":""},{"location":"extensions/vector/schema/#stac_generator.vector.schema.VectorConfig","title":"<code>VectorConfig</code>","text":"<p>               Bases: <code>SourceConfig</code></p> <p>Extended source config with EPSG code.</p>"},{"location":"extensions/vector/schema/#stac_generator.vector.schema.VectorConfig.epsg","title":"<code>epsg: int = 4326</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EPSG code for checking against EPSG code of the vector data</p>"}]}