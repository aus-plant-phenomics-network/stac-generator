{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>STAC is a json-based metadata standard for describing spatial-temporal assets, particularly satellite and Earth observation data. STAC allows users to quickly search, discover and use geospatial assets by providing a consistent structure for query and storage.</p> <p>The stac_generator can be used as a cross-platform command line interface (CLI) program or a python library that combines automatically extracted geospatial information from raw assets and other user-provided metadata to build a STAC-compliant metadata record for further use. Generated STAC records can be saved locally or behind a STAC API-compliant server.</p> <p>The stac_generator was developed as part of the Multiscalar Crop Characterisation Project (MCCN). Using the STAC generator to describe an asset collection is the first step in building a datacube with the MCCN engine.</p>"},{"location":"#installation","title":"Installation","text":"<p>Requirements: python3.11-3.12</p> <p>STAC Generator can be installed directly from Pypi:</p> <pre><code>pip install pystac-generator\n</code></pre> <p>Note that if you want STAC Generator to be accessible from everywhere (outside the environment where it is installed), you can install STAC Generator with pipx instead of pip. To install pipx, visit this.</p> <pre><code>pipx install pystac-generator\n</code></pre>"},{"location":"#upgrade","title":"Upgrade","text":"<p>Using pip:</p> <pre><code>pip install pystac-generator --upgrade\n</code></pre> <p>Using pipx:</p> <pre><code>pipx upgrade pystac-generator\n</code></pre>"},{"location":"composite/","title":"Composite","text":"<p>In many cases, it is common to have a collection with multiple items of different data types. There are two ways to serialise multiple items at once into a collection, either using an aggregated config file, or using multiple config files.</p> <p>In this tutorial, we will be describing the asset Werribee.geojson, vegetation_cover.tif, and soil_data.csv from the previous tutorials.</p> <p>Note that regardless of which method is used, each config entry must be a valid config, and the id for each config entry must be unique. The program will raise an error if either of those conditions are not fulfilled.</p>"},{"location":"composite/#multiple-config-files","title":"Multiple config files","text":"<p>Prepare the configs as described in the previous tutorials:</p> <ul> <li>vector_simple_config.json</li> <li>raster_custom_config.json</li> <li>point_simple_config.json</li> </ul> <p>Then run the following command:</p> <pre><code>stac_generator serialise \\\n  vector_simple_config.json\\\n  raster_custom_config.json\\\n  point_simple_config.json\n</code></pre> <p>To serialise items from multiple configs, we simply add the configs as positional parameters in the command line application.</p>"},{"location":"composite/#an-aggregated-config","title":"An aggregated config","text":"<p>To prepare an aggregated config, we simply add config item entries as a list to the config file:</p> jsonyaml composite_config.json<pre><code>[\n  {\n    \"id\": \"Werribee\",\n    \"location\": \"Werribee.geojson\",\n    \"collection_date\": \"2025-01-01\",\n    \"collection_time\": \"00:00:00\"\n  },\n  {\n    \"id\": \"vegetation_cover\",\n    \"location\": \"vegetation_cover.tif\",\n    \"collection_date\": \"2021-02-21\",\n    \"collection_time\": \"10:00:17\",\n    \"band_info\": [\n      {\n        \"name\": \"vegetation\",\n        \"description\": \"Vegetation cover level\"\n      }\n    ]\n  },\n  {\n    \"id\": \"soil_data\",\n    \"location\": \"soil_data.csv\",\n    \"collection_date\": \"2020-01-01\",\n    \"collection_time\": \"10:00:00\",\n    \"X\": \"Longitude\",\n    \"Y\": \"Latitude\",\n    \"epsg\": 4326,\n    \"column_info\": [\n      {\n        \"name\": \"Ca_Soln\",\n        \"description\": \"Calcium solution in ppm\"\n      },\n    ]\n  }\n]\n</code></pre> composite_config.yaml<pre><code>- id: \"Werribee\"\n  location: \"Werribee.geojson\"\n  collection_date: \"2025-01-01\"\n  collection_time: \"00:00:00\"\n- id: vegetation_cover\n  location: vegetation_cover.tif\n  collection_date: '2021-02-21'\n  collection_time: '10:00:17'\n  band_info:\n  - description: Vegetation cover level\n    name: vegetation\n- id: soil_data\n  location: soil_data.csv\n  epsg: 4326\n  X: Longitude\n  Y: Latitude\n  collection_date: '2020-01-01'\n  collection_time: '10:00:00'\n  column_info:\n  - description: Calcium solution in ppm\n    name: Ca_Soln\n</code></pre> <p>The collection can then be generated by running the command:</p> <pre><code>stac_generator serialise composite.json\n</code></pre>"},{"location":"exception/","title":"Exceptions","text":""},{"location":"exception/#exceptions.StacException","title":"<code>StacException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exceptions handled by the stac_generator. Asset exceptions and Config exceptions</p>"},{"location":"exception/#exceptions.SourceAssetException","title":"<code>SourceAssetException</code>","text":"<p>               Bases: <code>StacException</code></p> <p>Exception raised when the source data cannot be read by itself</p>"},{"location":"exception/#exceptions.SourceAssetLocationException","title":"<code>SourceAssetLocationException</code>","text":"<p>               Bases: <code>SourceAssetException</code></p> <p>Exception raised when the source asset location cannot be accessed</p>"},{"location":"exception/#exceptions.TimezoneException","title":"<code>TimezoneException</code>","text":"<p>               Bases: <code>StacException</code></p> <p>Exception raised when timezone information cannot be determined from geometry</p>"},{"location":"exception/#exceptions.StacConfigException","title":"<code>StacConfigException</code>","text":"<p>               Bases: <code>StacException</code></p> <p>Exception raised when the config metadata is misspecified</p>"},{"location":"exception/#exceptions.ConfigFormatException","title":"<code>ConfigFormatException</code>","text":"<p>               Bases: <code>StacConfigException</code></p> <p>Exception raised when the format of the config is invalid</p>"},{"location":"exception/#exceptions.InvalidExtensionException","title":"<code>InvalidExtensionException</code>","text":"<p>               Bases: <code>StacConfigException</code></p> <p>Exception raised when the config extension is unsupported</p>"},{"location":"exception/#exceptions.ColumnInfoException","title":"<code>ColumnInfoException</code>","text":"<p>               Bases: <code>StacConfigException</code></p> <p>Exception raised when information described in column info does not match source asset</p>"},{"location":"exception/#exceptions.BandInfoException","title":"<code>BandInfoException</code>","text":"<p>               Bases: <code>StacConfigException</code></p> <p>Exception raised when information described in band info does not match raster asset</p>"},{"location":"exception/#exceptions.JoinConfigException","title":"<code>JoinConfigException</code>","text":"<p>               Bases: <code>StacConfigException</code></p> <p>Exception raised when information provided in join config is invalid</p>"},{"location":"factory/","title":"Factory","text":""},{"location":"factory/#factory.StacGeneratorFactory","title":"<code>StacGeneratorFactory</code>","text":"<p>StacGeneratorFactory provides a factory method for getting configs and generating CollectionGenerator</p>"},{"location":"factory/#factory.StacGeneratorFactory.get_extension_config_handler","title":"<code>get_extension_config_handler(extension)</code>  <code>staticmethod</code>","text":"<p>Match file extension with SourceConfig type</p>"},{"location":"factory/#factory.StacGeneratorFactory.get_extension_handler","title":"<code>get_extension_handler(extension)</code>  <code>staticmethod</code>","text":"<p>Match file extension with SourceConfig type</p>"},{"location":"factory/#factory.StacGeneratorFactory.register_extension_handler","title":"<code>register_extension_handler(extension, handler, force=False)</code>  <code>staticmethod</code>","text":"<p>Dynamically register extension handler</p>"},{"location":"factory/#factory.StacGeneratorFactory.register_generator_handler","title":"<code>register_generator_handler(config_type, handler, force=False)</code>  <code>staticmethod</code>","text":"<p>Dynamically register a customer ItemGenerator class based on (new/existing) config type. Use force to overwrite existing handler</p>"},{"location":"factory/#factory.StacGeneratorFactory.get_generator_handler","title":"<code>get_generator_handler(config)</code>  <code>staticmethod</code>","text":"<p>Match ItemGenrator class based on config type</p>"},{"location":"factory/#factory.StacGeneratorFactory.extract_item_config","title":"<code>extract_item_config(item)</code>  <code>staticmethod</code>","text":"<p>Get stac_generator properties. Used by the MCCN engine</p>"},{"location":"factory/#factory.StacGeneratorFactory.get_collection_generator","title":"<code>get_collection_generator(source_configs, collection_config, pool=None)</code>  <code>staticmethod</code>","text":"<p>Get a CollectionGenerator instance based on source configs and collection config</p> <p>Parameters:</p> Name Type Description Default <code>source_configs</code> <code>Config_T</code> <p>extra metadata/generation parameters for</p> required <code>the</code> <code>collection's items. Source configs can be given as</code> required <code>collection_config</code> <code>StacCollectionConfig</code> <p>collection metadata.</p> required <code>pool</code> <code>Executor | None</code> <p>optional threadpool/process pool for parallel processing.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CollectionGenerator</code> <code>CollectionGenerator</code> <p>a collection generator instance, in which all items are derived</p> <code>CollectionGenerator</code> <p>from source _configs and general metadata derived from collection_config.</p>"},{"location":"generator/","title":"Generator","text":""},{"location":"generator/#core.base.generator.CollectionGenerator","title":"<code>CollectionGenerator</code>","text":"<p>CollectionGenerator class. User should not need to subclass this class unless greater control over how collection is generated from items is needed.</p>"},{"location":"generator/#core.base.generator.CollectionGenerator.__init__","title":"<code>__init__(collection_config, generators, pool=None)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>collection_config</code> <code>StacCollectionConfig</code> <p>collection metadata as a <code>StacCollectionConfig</code> object.</p> required <code>generators</code> <code>Sequence[ItemGenerator[T]]</code> <p>sequence of <code>ItemGenerator</code> objects.</p> required <code>pool</code> <code>Executor | None</code> <p>Executor pool for parallel processing. Defaults to None.</p> <code>None</code>"},{"location":"generator/#core.base.generator.CollectionGenerator.check_duplicated_id","title":"<code>check_duplicated_id()</code>","text":"<p>Validates that the items have unique id within this collection</p>"},{"location":"generator/#core.base.generator.CollectionGenerator.spatial_extent","title":"<code>spatial_extent(items)</code>  <code>staticmethod</code>","text":"<p>Extract a collection's spatial extent based on geometry information of its items.</p> <p>Produces the smallest bounding box that encloses all items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Sequence[pystac.Item]</code> <p>sequence of generated items</p> required <p>Returns:</p> Type Description <code>pystac.SpatialExtent</code> <p>pystac.SpatialExtent: the calculated spatial extent object</p>"},{"location":"generator/#core.base.generator.CollectionGenerator.temporal_extent","title":"<code>temporal_extent(items)</code>  <code>staticmethod</code>","text":"<p>Extract a collection's temporal extent based on time information of its items.</p> <p>Produces the tuple (start_ts, end_ts) which are the smallest and largest timestamps of the Items' start_datetime and end_datetime values.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Sequence[pystac.Item]</code> <p>sequence of generated items</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if an item's datetime attribute cannot be accessed</p> <p>Returns:</p> Type Description <code>pystac.TemporalExtent</code> <p>pystac.TemporalExtent: the calculated [start_ts, end_ts] object.</p>"},{"location":"generator/#core.base.generator.CollectionGenerator.__call__","title":"<code>__call__()</code>","text":"<p>Generate all items from <code>ItemGenerator</code> then generate the Collection object</p>"},{"location":"generator/#core.base.generator.ItemGenerator","title":"<code>ItemGenerator</code>","text":"<p>               Bases: <code>abc.ABC</code>, <code>Generic[T]</code></p> <p>Base ItemGenerator object. Users should extend this class for handling different file extensions.</p>"},{"location":"generator/#core.base.generator.ItemGenerator.source_type","title":"<code>source_type</code>  <code>instance-attribute</code>","text":"<p>SourceConfig subclass that contains information used for parsing the source file</p>"},{"location":"generator/#core.base.generator.ItemGenerator.__init__","title":"<code>__init__(config)</code>","text":"<p>Base ItemGenerator object. Users should extend this class for handling different file extensions.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | T</code> <p>source data configs - either from csv config or yaml/json</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if an invalid config is provided</p>"},{"location":"generator/#core.base.generator.ItemGenerator.generate","title":"<code>generate()</code>  <code>abstractmethod</code>","text":"<p>Abstract method that handles <code>pystac.Item</code> generation from the appropriate config</p>"},{"location":"generator/#core.base.generator.BaseVectorGenerator","title":"<code>BaseVectorGenerator</code>","text":"<p>               Bases: <code>ItemGenerator[T]</code></p> <p>Base Generator Object for handling vector and point assets</p>"},{"location":"generator/#core.base.generator.BaseVectorGenerator.geometry","title":"<code>geometry(df)</code>  <code>staticmethod</code>","text":"<p>Calculate the geometry from geopandas dataframe.</p> <p>If geopandas dataframe has only one item, the geometry will be that of the item. If geopandas dataframe has less than 10 items of the same type, the geometry will be the Multi version of the type. Note that MultiPoint will be unpacked into points for the 10 items limit. If there are more than 10 items of the same type or there are items of different types i.e. Point and LineString, the returned geometry will be the Polygon of the bounding box. Note that Point and MultiPoint are treated as the same type (so are type and its Multi version).</p> <p>Returns:</p> Name Type Description <code>Geometry</code> <code>Geometry</code> <p>extracted geometry</p>"},{"location":"generator/#core.base.generator.BaseVectorGenerator.df_to_item","title":"<code>df_to_item(df, assets, source_config, properties, epsg=4326, time_column=None)</code>  <code>staticmethod</code>","text":"<p>Convert dataframe to pystac.Item</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>gpd.GeoDataFrame</code> <p>input dataframe</p> required <code>assets</code> <code>dict[str, pystac.Asset]</code> <p>data asset object</p> required <code>source_config</code> <code>SourceConfig</code> <p>config object</p> required <code>properties</code> <code>dict[str, Any]</code> <p>serialised properties</p> required <code>epsg</code> <code>int</code> <p>frame's epsg code. Defaults to 4326.</p> <code>4326</code> <code>time_column</code> <code>str | None</code> <p>datetime column in the dataframe. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pystac.Item</code> <p>pystac.Item: generated STAC Item</p>"},{"location":"generator/#core.base.generator.StacSerialiser","title":"<code>StacSerialiser</code>","text":"<p>Class that handles validating generated stac metadata and storing them locally or remotely</p>"},{"location":"generator/#core.base.generator.StacSerialiser.__init__","title":"<code>__init__(generator, href)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>CollectionGenerator</code> <p>collection generator object</p> required <code>href</code> <code>str | Path</code> <p>serialisation location</p> required"},{"location":"generator/#core.base.generator.StacSerialiser.pre_serialisation_hook","title":"<code>pre_serialisation_hook(collection, href)</code>","text":"<p>Hook that can be overwritten to provide pre-serialisation functionality. By default, this normalises collection href and performs validation</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>pystac.Collection</code> <p>stac Collection</p> required <code>href</code> <code>str</code> <p>href for normalisation</p> required"},{"location":"generator/#core.base.generator.StacSerialiser.__call__","title":"<code>__call__()</code>","text":"<p>Call API for serialisation</p>"},{"location":"generator/#core.base.generator.StacSerialiser.prepare_collection_configs","title":"<code>prepare_collection_configs(collection_generator)</code>  <code>staticmethod</code>","text":"<p>Convert the configs of all items in the collection to a list of python dictionaries</p>"},{"location":"generator/#core.base.generator.StacSerialiser.prepare_config","title":"<code>prepare_config(config)</code>  <code>staticmethod</code>","text":"<p>Convert config object to python dictionary</p>"},{"location":"generator/#core.base.generator.StacSerialiser.save_collection_config","title":"<code>save_collection_config(dst)</code>","text":"<p>Convenient API for writing all the config of all items in the collection to a dst</p>"},{"location":"generator/#core.base.generator.StacSerialiser.save_configs","title":"<code>save_configs(configs, dst)</code>  <code>staticmethod</code>","text":"<p>Convenient API for writing a sequence of config objects to dst</p>"},{"location":"generator/#core.base.generator.StacSerialiser.to_json","title":"<code>to_json()</code>","text":"<p>Generate STAC Collection and save to disk as json files</p>"},{"location":"generator/#core.base.generator.StacSerialiser.to_api","title":"<code>to_api()</code>","text":"<p>_Generate STAC Collection and push to remote API. The API will first attempt to send a POST request which will be replaced with a PUT request if a 409 error is encountered</p>"},{"location":"generator/#core.point.generator.PointGenerator","title":"<code>PointGenerator</code>","text":"<p>               Bases: <code>BaseVectorGenerator[PointConfig]</code></p> <p>ItemGenerator class that handles point data in csv format</p>"},{"location":"generator/#core.point.generator.PointGenerator.generate","title":"<code>generate()</code>","text":"<p>Generate a STAC Item based on provided point config</p> <p>Returns:</p> Type Description <code>pystac.Item</code> <p>pystac.Item: generated STAC Item</p>"},{"location":"generator/#core.vector.generator.VectorGenerator","title":"<code>VectorGenerator</code>","text":"<p>               Bases: <code>BaseVectorGenerator[VectorConfig]</code></p> <p>ItemGenerator class that handles vector data with common vector formats - i.e (shp, zipped shp, gpkg, geojson)</p>"},{"location":"generator/#core.vector.generator.VectorGenerator.generate","title":"<code>generate()</code>","text":"<p>Create a STAC Item from a VectorConfig</p> <p>Raises:</p> Type Description <code>StacConfigException</code> <p>if the stac config fails a validation check</p> <p>Returns:</p> Type Description <code>pystac.Item</code> <p>pystac.Item: generated STAC Item</p>"},{"location":"generator/#core.raster.generator.RasterGenerator","title":"<code>RasterGenerator</code>","text":"<p>               Bases: <code>ItemGenerator[RasterConfig]</code></p> <p>Raster Generator</p>"},{"location":"generator/#core.raster.generator.RasterGenerator.generate","title":"<code>generate()</code>","text":"<p>Generate a STAC Item from RasterConfig</p> <p>Raises:</p> Type Description <code>SourceAssetException</code> <p>if the data cannot be accessed</p> <p>Returns:</p> Type Description <code>pystac.Item</code> <p>pystac.Item: generated STAC Item</p>"},{"location":"misc/","title":"Misc","text":""},{"location":"misc/#timezone","title":"Timezone","text":"<p>If the <code>timezone</code> field is not provided as part of the config, the program will use the default value <code>local</code>. Valid options for <code>timezone</code> are:</p> <ul> <li><code>local</code>: local tz determined from asset's geometry.</li> <li><code>utc</code>: utc</li> <li>timezone information compatible with <code>pytz.all_timezones</code>.</li> </ul> <p>This affects datetime information associated with the project, including:</p> <ul> <li><code>item.datetime</code> from <code>collection_date</code> and <code>collection_time</code>.</li> <li>Date information from date columns in the asset.</li> </ul> <p>Please refer to this documentation on how time data is processed.</p>"},{"location":"misc/#collection-metadata","title":"Collection Metadata","text":"<p>Collection metadata can be provided for serialisation as part of the command line. The supported metadata for collection includes:</p> <ul> <li><code>id</code>: collection's id</li> <li><code>title</code>: collection's title</li> <li><code>description</code>: collection's description</li> <li><code>license</code>: collection's license</li> </ul> <p>For instance, to serialise items described in a file <code>config.json</code> with additional id, title, description and license information, we can run the following command:</p> <pre><code>stac_generator serialise config.json\\\n    --id CollectionID \\\n    --title CollectionTitle \\\n    --description CollectionDescription \\\n    --license MIT\\\n</code></pre>"},{"location":"misc/#serialisation-destination","title":"Serialisation Destination","text":"<p>Serialisation option is provided in the command line through the flag <code>--dst</code>, specifying the location where the serialised STAC metadata will be stored. The default value for dst is <code>generated</code>, which creates the folder <code>generated</code> in the current directory. Users can provide either a local location to dst, or a STAC API compliant url, in which case the metadata will be stored behind an api server. Assuming there exists a STAC API server whose endpoint is <code>http:102.9.0.32:8082</code>. To serialise a collection described in <code>config.json</code> to this destination, we can run:</p> <pre><code>stac_generator serialise config.json\n</code></pre>"},{"location":"module/","title":"Module","text":"<p>In the previous tutorials, we have seen how the STAC Generator can be used as a command line tool to generate STAC metadata. In this section, we will demonstrate how to write a Python script that imports the <code>stac_generator</code> module and use that to generate a composite configuration.</p> <pre><code>import datetime\nfrom typing import Any\n\nfrom stac_generator.core.base.generator import StacSerialiser\nfrom stac_generator.core.base.schema import ColumnInfo, StacCollectionConfig\nfrom stac_generator.core.point.schema import PointConfig\nfrom stac_generator.factory import StacGeneratorFactory\n\n# Defining a config from a json file\n\nvector_config: str = \"vector_simple_config.json\"\n\n# Defining a config as a dictionary\n\nraster_config: dict[str, Any] = {\n    \"id\": \"vegetation_cover\",\n    \"location\": \"vegetation_cover.tif\",\n    \"collection_date\": \"2021-02-21\",\n    \"collection_time\": \"10:00:17\",\n    \"band_info\": [{\"name\": \"vegetation\", \"description\": \"Vegetation cover level\"}],\n}\n\n# Defining a config as a Config object\npoint_config = PointConfig(\n    id=\"soil_data\",\n    location=\"soil_data.csv\",\n    collection_date=datetime.date(2020, 1, 1),\n    collection_time=datetime.time(10),\n    X=\"Longitude\",\n    Y=\"Latitude\",\n    epsg=4326,\n    column_info=[ColumnInfo(name=\"Cal_Soln\", description=\"Calcium Soln in ppm\")],\n)\n\n# Create a Collection Generator\ncollection_generator = StacGeneratorFactory.get_collection_generator(\n    source_configs=[point_config, vector_config, raster_config],\n    collection_config=StacCollectionConfig(id=\"collection\"),\n)\n# Serialise data\nserialiser = StacSerialiser(collection_generator, \"generated\")\nserialiser()\n</code></pre>"},{"location":"point/","title":"Point","text":"<p>The <code>stac_generator</code> uses the <code>csv</code> and <code>txt</code> extensions to describe point data. In addition to the minimum required fields, the STAC generator requires a few additional parameters to properly parse the asset.</p> <p>Given the flexibility of the csv format, we require point dataset to be structured in a particular way. Each row of the csv file describes a point, with columns being the attributes. At the minimum, there must be two columns describing the coordinates of the points, with the common options being <code>lat/lon</code>, <code>y/x</code>, <code>northings/eastings</code>, etc. The required config fields include:</p> <ul> <li><code>X</code>: the column in the csv asset to describe the longitude.</li> <li><code>Y</code>: the column in the csv asset to describe the latitude.</li> <li><code>epsg</code>: the crs of the <code>X</code>, <code>Y</code> columns.</li> </ul> <p>There can also be optional columns:</p> <ul> <li><code>T</code>: the column in the csv asset that describes the date of collection of a point record.</li> <li><code>date_format</code>: how the date string is interpreted - by default, dates are assumed to be <code>ISO8640</code> compliant.</li> <li><code>Z</code>: the column in the csv asset that describes the altitude.</li> <li><code>column_info</code>: describe the relevant names and descriptions of relavant attributes.</li> </ul>"},{"location":"point/#generic-point-data","title":"Generic Point Data","text":"<p>In this tutorial, we will describe the asset <code>soil_data.csv</code> contained in the zip folder.</p> Longitude Latitude mid_depth Ca_Soln 150.547 -24.3399 0.05 85.25 150.547 -24.3399 0.2 361.1 150.547 -24.3399 0.4 295.8 150.551 -24.3403 0.05 230.2 150.551 -24.3403 0.2 222.85 150.551 -24.3403 0.4 157.5 150.555 -24.3409 0.05 42.58 150.555 -24.3409 0.2 34.97 150.555 -24.3409 0.4 47.815 150.551 -24.3395 0.05 222.35 150.551 -24.3395 0.2 214.85 150.551 -24.3395 0.4 158.15 150.549 -24.3383 0.05 78.4 150.549 -24.3383 0.2 196.05 150.549 -24.3383 0.4 249.25 150.552 -24.3388 0.05 191.15 150.552 -24.3388 0.2 203.4 150.552 -24.3388 0.4 156.75 150.554 -24.339 0.05 53.05 150.554 -24.339 0.2 36.675 150.554 -24.339 0.4 62.1 150.553 -24.3376 0.05 88.55 150.553 -24.3376 0.2 69.65 150.553 -24.3376 0.4 29.245 150.556 -24.338 0.05 43.945 150.556 -24.338 0.2 29.185 150.556 -24.338 0.4 33.32 150.552 -24.3367 0.05 58.85 150.552 -24.3367 0.2 57.85 150.552 -24.3367 0.4 30.12 150.554 -24.3364 0.05 171.7 150.554 -24.3364 0.2 60.05 150.554 -24.3364 0.4 45.795 150.556 -24.336 0.05 83.55 150.556 -24.336 0.2 37.535 150.556 -24.336 0.4 43.605"},{"location":"point/#config","title":"Config","text":"<p>The config - <code>point_simple_config.json</code> is described below:</p> jsonyaml point_simple_config.json<pre><code>[\n  {\n    \"id\": \"soil_data\",\n    \"location\": \"soil_data.csv\",\n    \"collection_date\": \"2020-01-01\",\n    \"collection_time\": \"10:00:00\",\n    \"X\": \"Longitude\",\n    \"Y\": \"Latitude\",\n    \"epsg\": 4326,\n    \"column_info\": [\n      {\n        \"name\": \"Ca_Soln\",\n        \"description\": \"Calcium solution in ppm\"\n      }\n    ]\n  }\n]\n</code></pre> point_simple_config.yaml<pre><code>- id: soil_data\n  location: soil_data.csv\n  epsg: 4326\n  X: Longitude\n  Y: Latitude\n  collection_date: '2020-01-01'\n  collection_time: '10:00:00'\n  column_info:\n  - description: Calcium solution in ppm\n    name: Ca_Soln\n</code></pre>"},{"location":"point/#field-explanations","title":"Field Explanations","text":"<ul> <li><code>X</code>: the x coordinate of the data is <code>Longitude</code>.</li> <li><code>Y</code>: the y coordinate of the data is <code>Latitude</code>.</li> <li><code>epsg</code>: we assume the data is recorded in WGS84 or epsg 4326.</li> <li><code>column_info</code>: similar to the same field in vector assets. This is a list of column objects with fields <code>name</code> and <code>description</code>. In this example, we describe the attribute <code>ca_soln</code>.</li> </ul>"},{"location":"point/#command-and-output","title":"Command and Output","text":"<p>Save the config file as <code>point_simple_config.json</code> and run the follow serialisation command:</p> <pre><code>stac_generator serialise point_simple_config.json\n</code></pre>"},{"location":"point/#timeseries-point-data","title":"Timeseries Point Data","text":"<p>In this tutorial, we describe the asset <code>adelaide_airport.csv</code> which contains weather station collected by a BOM station in the area:</p> latitude longitude elevation station YYYY-MM-DD daily_rain max_temp min_temp radiation mslp -34.9524 138.52 2 23034 2023-01-01 0 32.2 17 31.8 1007.4 -34.9524 138.52 2 23034 2023-01-02 0 26.9 16.8 31.7 1007.5 -34.9524 138.52 2 23034 2023-01-03 0 24.1 16.5 29 1012.9 -34.9524 138.52 2 23034 2023-01-04 0 22.9 14.9 25.3 1014.9 -34.9524 138.52 2 23034 2023-01-05 0 24.8 14 31.6 1016.8 -34.9524 138.52 2 23034 2023-01-06 0 28.8 15.9 31.7 1014.1 -34.9524 138.52 2 23034 2023-01-07 0 35.1 18.3 31.5 1008.8 -34.9524 138.52 2 23034 2023-01-08 0 36.1 20.2 31.4 1008.2 -34.9524 138.52 2 23034 2023-01-09 0 31.1 17.5 31.1 1013.9 -34.9524 138.52 2 23034 2023-01-10 0 29.5 15.9 31.2 1014.8 -34.9524 138.52 2 23034 2023-01-11 0 27.1 15.9 31 1011.3 -34.9524 138.52 2 23034 2023-01-12 0 33.1 15.8 31.1 1013.8 -34.9524 138.52 2 23034 2023-01-13 0 34.7 17.1 31 1015.2 -34.9524 138.52 2 23034 2023-01-14 0 40.4 25.7 26.1 1009.3 -34.9524 138.52 2 23034 2023-01-15 0 25.3 16.3 25 1019.7 -34.9524 138.52 2 23034 2023-01-16 0 34.3 17.4 29.9 1016.8 -34.9524 138.52 2 23034 2023-01-17 0 38.1 22.1 14 1009.5 -34.9524 138.52 2 23034 2023-01-18 2.6 21.6 18.5 13.6 1015.4 -34.9524 138.52 2 23034 2023-01-19 0 22.8 14.8 29.2 1020.4 -34.9524 138.52 2 23034 2023-01-20 0 25.1 13.5 26.5 1017.7 -34.9524 138.52 2 23034 2023-01-21 0 27.7 15.4 30.4 1015.3 -34.9524 138.52 2 23034 2023-01-22 0 30.1 15.7 30.1 1016.3 -34.9524 138.52 2 23034 2023-01-23 0 29.9 16.1 22.8 1013.1 -34.9524 138.52 2 23034 2023-01-24 0 29.5 17 30 1011.9 -34.9524 138.52 2 23034 2023-01-25 0.2 24.4 14.4 30 1011.9 -34.9524 138.52 2 23034 2023-01-26 0 27.8 14.7 29.3 1018 -34.9524 138.52 2 23034 2023-01-27 0 37.8 13.4 29.4 1012.9 -34.9524 138.52 2 23034 2023-01-28 0 27.6 24.1 8.2 1008.2 -34.9524 138.52 2 23034 2023-01-29 14.2 23.5 19.2 10.5 1012.2 -34.9524 138.52 2 23034 2023-01-30 0 25.2 16 29 1014.9 -34.9524 138.52 2 23034 2023-01-31 0 23.5 13.8 29.4 1011.3 -34.9524 138.52 2 23034 2023-02-01 0 22.1 12.7 14.5 1010.4"},{"location":"point/#config_1","title":"Config","text":"<p>We prepare the <code>point_time_series_config.json</code> as follows:</p> jsonyaml point_time_series_config.json<pre><code>[\n  {\n    \"id\": \"adelaide_airport\",\n    \"location\": \"adelaide_airport.csv\",\n    \"collection_date\": \"2023-01-01\",\n    \"collection_time\": \"09:00:00\",\n    \"X\": \"longitude\",\n    \"Y\": \"latitude\",\n    \"Z\": \"elevation\",\n    \"T\": \"YYYY-MM-DD\",\n    \"epsg\": 7843,\n    \"column_info\": [\n      {\n        \"name\": \"daily_rain\",\n        \"description\": \"Observed daily rain fall in mm\"\n      },\n      {\n        \"name\": \"max_temp\",\n        \"description\": \"Observed daily maximum temperature in degree C\"\n      },\n      {\n        \"name\": \"min_temp\",\n        \"description\": \"Observed daily minimum temperature in degree C\"\n      },\n      {\n        \"name\": \"radiation\",\n        \"description\": \"Total incoming downward shortwave radiation on a horizontal surface MJ/sqm\"\n      },\n      {\n        \"name\": \"mslp\",\n        \"description\": \"Mean sea level pressure in hPa\"\n      }\n    ]\n  }\n]\n</code></pre> point_time_series_config.yaml<pre><code>- id: adelaide_airport\n  location: adelaide_airport.csv\n  collection_date: '2023-01-01'\n  collection_time: 09:00:00\n  X: longitude\n  Y: latitude\n  Z: elevation\n  T: YYYY-MM-DD\n  epsg: 7843\n  column_info:\n  - description: Observed daily rain fall in mm\n    name: daily_rain\n  - description: Observed daily maximum temperature in degree C\n    name: max_temp\n  - description: Observed daily minimum temperature in degree C\n    name: min_temp\n  - description: Total incoming downward shortwave radiation on a horizontal surface\n      MJ/sqm\n    name: radiation\n  - description: Mean sea level pressure in hPa\n    name: mslp\n</code></pre>"},{"location":"point/#field-explanation","title":"Field Explanation","text":"<ul> <li><code>T</code>: describe the name of the time column - i.e. <code>YYYY-MM-DD</code>.</li> </ul> <p>In summary, the values for <code>X</code>, <code>Y</code>, <code>Z</code>, <code>T</code> are obtained from the raw csv - i.e. longitude, latitude, elevation and YYYY-MM-DD respectively.</p> <p><code>epsg</code> value cannot be derived from the csv and must be known by the user - i.e. reading dataset metadata on BOM/SILO website.</p>"},{"location":"point/#command-and-output_1","title":"Command and Output","text":"<p>Save the config as <code>point_time_series_config.json</code>. Run the following command to serialise the metadata:</p> <pre><code>stac_generator serialise point_time_series_config.json\n</code></pre>"},{"location":"raster/","title":"Raster","text":"<p>For raster assets (<code>tif</code>, <code>geotif</code>, <code>tiff</code>, <code>geotiff</code> extensions), in addition to the required fields, users are required to declare recorded bands under <code>band_info</code> field.</p>"},{"location":"raster/#common-bands","title":"Common bands","text":"<p>In this tutorial, we will describe the asset <code>L2A_PVI.tif</code> from the zip folder. The asset is an RGB image with RGB bands.</p> <p></p>"},{"location":"raster/#config","title":"Config","text":"<p>We will prepare the following <code>raster_simple_config.json</code>:</p> jsonyaml raster_simple_config.json<pre><code>[\n  {\n    \"id\": \"L2A_PVI\",\n    \"location\": \"L2A_PVI.tif\",\n    \"collection_date\": \"2021-02-21\",\n    \"collection_time\": \"10:00:17\",\n    \"band_info\": [\n      {\n        \"name\": \"R\",\n        \"common_name\": \"red\",\n        \"description\": \"Common name: red, Range: 0.6 to 0.7\",\n        \"wavelength\": 0.6645\n      },\n      {\n        \"name\": \"G\",\n        \"common_name\": \"green\",\n        \"description\": \"Common name: green, Range: 0.5 to 0.6\",\n        \"wavelength\": 0.56\n      },\n      {\n        \"name\": \"B\",\n        \"common_name\": \"blue\",\n        \"description\": \"Common name: blue, Range: 0.45 to 0.5\",\n        \"wavelength\": 0.4966\n      }\n    ]\n  }\n]\n</code></pre> raster_simple_config.yaml<pre><code>- id: L2A_PVI\n  location: L2A_PVI.tif\n  collection_date: '2021-02-21'\n  collection_time: '10:00:17'\n  band_info:\n  - common_name: red\n    description: 'Common name: red, Range: 0.6 to 0.7'\n    name: R\n    wavelength: 0.6645\n  - common_name: green\n    description: 'Common name: green, Range: 0.5 to 0.6'\n    name: G\n    wavelength: 0.56\n  - common_name: blue\n    description: 'Common name: blue, Range: 0.45 to 0.5'\n    name: B\n    wavelength: 0.4966\n</code></pre>"},{"location":"raster/#field-explanation","title":"Field explanation:","text":"<p><code>band_info</code> is a list of band objects represented in the raster:</p> <ul> <li><code>name</code>: band's name</li> <li><code>common_name</code>: band's name that are more well-known.</li> <li><code>wavelength</code>: band's wavelength</li> <li><code>description</code>: band's description</li> </ul> <p>Aside from <code>name</code>, other fields are optional. Note that <code>common_name</code> supports a very small subset of well-known names. If users provide a <code>common_name</code> value that is not on this list, the program will raise an error.</p>"},{"location":"raster/#command-and-output","title":"Command and Output","text":"<p>Save the config as <code>raster_simple_config.json</code> and run the following command:</p> <pre><code>stac_generator serialise raster_simple_config.json\n</code></pre>"},{"location":"raster/#uncommonunknown-bands","title":"Uncommon/unknown bands","text":"<p>In this tutorial, we will use the asset <code>vegetation_cover.tif</code> asset, which contains a custom band <code>vegetation_cover</code>.</p> <p></p>"},{"location":"raster/#config_1","title":"Config","text":"<p>We will prepare the following <code>raster_custom_config.json</code>:</p> jsonyaml raster_custom_config.json<pre><code>[\n  {\n    \"id\": \"vegetation_cover\",\n    \"location\": \"vegetation_cover.tif\",\n    \"collection_date\": \"2021-02-21\",\n    \"collection_time\": \"10:00:17\",\n    \"band_info\": [\n      {\n        \"name\": \"vegetation\",\n        \"description\": \"Vegetation cover level\"\n      }\n    ]\n  }\n]\n</code></pre> raster_custom_config.yaml<pre><code>- id: vegetation_cover\n  location: vegetation_cover.tif\n  collection_date: '2021-02-21'\n  collection_time: '10:00:17'\n  band_info:\n  - description: Vegetation cover level\n    name: vegetation\n</code></pre> <p>Note that we only provide name and description since other information is unknown.</p>"},{"location":"raster/#command-and-output_1","title":"Command and Output","text":"<p>To serialise the metadata. Save the config as <code>raster_custom_config.json</code> and run the serialisation command:</p> <pre><code>stac_generator serialise raster_custom_config.json\n</code></pre>"},{"location":"schema/","title":"Schema","text":""},{"location":"schema/#core.base.schema.ASSET_KEY","title":"<code>ASSET_KEY = 'data'</code>  <code>module-attribute</code>","text":"<p>Constant describing the primary asset key</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig","title":"<code>StacCollectionConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains parameters to pass to Collection constructor. Also contains other metadata except for datetime related metadata.</p> <p>This config provides additional information that can not be derived from source file, which includes Stac Common Metadata and other descriptive information such as the id of the new entity</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>Item id</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.title","title":"<code>title = 'Auto-generated Stac Item'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A human readable title describing the item entity. See more</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.description","title":"<code>description = 'Auto-generated Stac Item'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Detailed multi-line description to fully explain the STAC entity. See more</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.license","title":"<code>license = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>License(s) of the data as SPDX License identifier, SPDX License expression, or other - See more</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.providers","title":"<code>providers = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of providers, which may include all organizations capturing or processing the data or the hosting provider. Providers should be listed in chronological order with the most recent provider being the last element of the list. - See more</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.platform","title":"<code>platform = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique name of the specific platform to which the instrument is attached. See more</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.instruments","title":"<code>instruments = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of instrument or sensor used (e.g., MODIS, ASTER, OLI, Canon F-1). See more</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.constellation","title":"<code>constellation = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the constellation to which the platform belongs. See more</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.mission","title":"<code>mission = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the mission for which data is collected. See more</p>"},{"location":"schema/#core.base.schema.StacItemConfig","title":"<code>StacItemConfig</code>","text":"<p>               Bases: <code>StacCollectionConfig</code></p> <p>Contains parameters related to collection date, time and timezone.</p> <p>A STAC Item's <code>datetime</code> field is derived from the combination of <code>collection_date</code>, <code>collection_time</code> and <code>timezone</code>. If the asset contains a timeseries, in which some values are not timezone aware, the timestamp is embedded with timezone information from the parameter <code>timezone</code>.</p>"},{"location":"schema/#core.base.schema.StacItemConfig.collection_date","title":"<code>collection_date</code>  <code>instance-attribute</code>","text":"<p>Date when the data is collected</p>"},{"location":"schema/#core.base.schema.StacItemConfig.collection_time","title":"<code>collection_time</code>  <code>instance-attribute</code>","text":"<p>Time when the data is collected</p>"},{"location":"schema/#core.base.schema.StacItemConfig.timezone","title":"<code>timezone = 'local'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>How timestamps associated with the Item is interpreted. If timezone is local, timezone information is derived from geometry. If timezone is a valid IANA timezone, non tz-aware timestamps will be embedded with timezone information. If an invalid timezone is provided, will raise an error.</p>"},{"location":"schema/#core.base.schema.StacItemConfig.get_datetime","title":"<code>get_datetime(geometry)</code>","text":"<p>Method to derive item's datetime based on collection date, collection time, and potentially geometry</p>"},{"location":"schema/#core.base.schema.SourceConfig","title":"<code>SourceConfig</code>","text":"<p>               Bases: <code>StacItemConfig</code></p> <p>Base source config that should be subclassed for different file extensions.</p> <p>Source files contain raw spatial information (i.e. geotiff, shp, csv) from which some Stac metadata can be derived. SourceConfig describes:</p> <ul> <li>The access mechanisms for the source file: stored on local disk, or hosted somewhere behind an api endpoint. If the source file must be accessed through an endpoint, users can provide additional HTTP information that forms the HTTP request to the host server.</li> <li>Processing information that are unique for the source type. Users should inherit <code>SourceConfig</code> for file extensions currently unsupported.</li> <li>Additional Stac Metadata from <code>StacConfig</code></li> </ul>"},{"location":"schema/#core.base.schema.SourceConfig.location","title":"<code>location</code>  <code>instance-attribute</code>","text":"<p>Asset's href</p>"},{"location":"schema/#core.base.schema.SourceConfig.extension","title":"<code>extension = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Explicit file extension specification. If the file is stored behind an api endpoint, the field <code>extension</code> must be provided</p>"},{"location":"schema/#core.base.schema.SourceConfig.method","title":"<code>method = 'GET'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTPMethod to acquire the file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.params","title":"<code>params = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query params for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.headers","title":"<code>headers = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query headers for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.cookies","title":"<code>cookies = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query cookies for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.content","title":"<code>content = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.json_body","title":"<code>json_body = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.to_common_metadata","title":"<code>to_common_metadata()</code>","text":"<p>Method to convert config to a python dictionary of common metadata excluding id</p>"},{"location":"schema/#core.base.schema.SourceConfig.to_asset_config","title":"<code>to_asset_config()</code>","text":"<p>Abstract method that dictates how config should be serialised that contains the minimum information to intepret the asset. SourceConfig subclasses should inherit and override this method.</p>"},{"location":"schema/#core.base.schema.SourceConfig.to_properties","title":"<code>to_properties()</code>","text":"<p>Method to convert config to properties dictionary to be added to Item's properties field. This includes <code>timezone</code> attribute and <code>stac_generator</code> key value pairs derived from <code>to_asset_config</code>.</p>"},{"location":"schema/#core.base.schema.ColumnInfo","title":"<code>ColumnInfo</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict description of GeoDataFrame columns. Used for describing vector/point attributes</p>"},{"location":"schema/#core.base.schema.ColumnInfo.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Column name</p>"},{"location":"schema/#core.base.schema.ColumnInfo.description","title":"<code>description</code>  <code>instance-attribute</code>","text":"<p>Column description</p>"},{"location":"schema/#core.base.schema.ColumnInfo.dtype","title":"<code>dtype</code>  <code>instance-attribute</code>","text":"<p>Column data type</p>"},{"location":"schema/#core.base.schema.HasColumnInfo","title":"<code>HasColumnInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin that provides column info field</p>"},{"location":"schema/#core.base.schema.HasColumnInfo.column_info","title":"<code>column_info = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of attributes associated with point/vector data</p>"},{"location":"schema/#core.vector.schema.VectorOwnConfig","title":"<code>VectorOwnConfig</code>","text":"<p>               Bases: <code>HasColumnInfo</code></p> <p>Config that defines the minimum information for parsing and reading vector asset. This config is produced for vector asset when the method <code>to_asset_config</code> is invoked, or when <code>StacGeneratorFactory.extract_item_config</code> is called on a vector STAC Item.</p>"},{"location":"schema/#core.vector.schema.VectorOwnConfig.layer","title":"<code>layer = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vector layer for multi-layer shapefile.</p>"},{"location":"schema/#core.vector.schema.VectorOwnConfig.join_config","title":"<code>join_config = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Config for join asset if valid available.</p>"},{"location":"schema/#core.vector.schema.VectorOwnConfig.check_join_fields_described","title":"<code>check_join_fields_described()</code>","text":"<p>Validates that if join config is provided, the field <code>left_on</code> must be described by the vector's <code>column_info</code>. Also validates that <code>right_on</code> must be described by the join config's <code>column_info</code>.</p>"},{"location":"schema/#core.vector.schema.VectorConfig","title":"<code>VectorConfig</code>","text":"<p>               Bases: <code>SourceConfig</code>, <code>VectorOwnConfig</code></p> <p>Extends SourceConfig to describe vector asset.</p>"},{"location":"schema/#core.vector.schema.VectorConfig.to_asset_config","title":"<code>to_asset_config()</code>","text":"<p>Produce a dictionary that has the signature of <code>VectorOwnConfig</code></p>"},{"location":"schema/#core.vector.schema.JoinConfig","title":"<code>JoinConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for join asset. This also contains information on how the vector asset and the join asset should be merged.</p> <p>Merge terminologies are consistent with pandas', where the vector asset is treated as the left table, and the join asset is the right table.</p>"},{"location":"schema/#core.vector.schema.JoinConfig.file","title":"<code>file</code>  <code>instance-attribute</code>","text":"<p>Path to asset. Must be a string or a Path.</p>"},{"location":"schema/#core.vector.schema.JoinConfig.left_on","title":"<code>left_on</code>  <code>instance-attribute</code>","text":"<p>Vector asset's attribute for joining.</p>"},{"location":"schema/#core.vector.schema.JoinConfig.right_on","title":"<code>right_on</code>  <code>instance-attribute</code>","text":"<p>Join asset's attribute for joining.</p>"},{"location":"schema/#core.vector.schema.JoinConfig.date_column","title":"<code>date_column = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the attribute in the join asset to be treated as timestamps.</p>"},{"location":"schema/#core.vector.schema.JoinConfig.date_format","title":"<code>date_format = 'ISO8601'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Format for intepreting timestamps. Accepted values follows strptime/strftime formats.</p>"},{"location":"schema/#core.vector.schema.JoinConfig.column_info","title":"<code>column_info</code>  <code>instance-attribute</code>","text":"<p>List of join asset column attribute. Note that for join assset, this cannot be empty.</p>"},{"location":"schema/#core.vector.schema.JoinConfig.check_non_empty_column_info","title":"<code>check_non_empty_column_info(value)</code>  <code>classmethod</code>","text":"<p>Method to validate that column info is non empty</p>"},{"location":"schema/#core.point.schema.PointOwnConfig","title":"<code>PointOwnConfig</code>","text":"<p>               Bases: <code>HasColumnInfo</code></p> <p>Source config for point(csv) data. This config is produced for point asset when the method <code>to_asset_config</code> is invoked, or when <code>StacGeneratorFactory.extract_item_config</code> is called on a point STAC Item.</p>"},{"location":"schema/#core.point.schema.PointOwnConfig.X","title":"<code>X</code>  <code>instance-attribute</code>","text":"<p>Column to be treated as longitude/X coordinate</p>"},{"location":"schema/#core.point.schema.PointOwnConfig.Y","title":"<code>Y</code>  <code>instance-attribute</code>","text":"<p>Column to be treated as latitude/Y coordinate</p>"},{"location":"schema/#core.point.schema.PointOwnConfig.Z","title":"<code>Z = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Column to be treated as altitude/Z coordinate</p>"},{"location":"schema/#core.point.schema.PointOwnConfig.T","title":"<code>T = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Column to be treated as time coordinate</p>"},{"location":"schema/#core.point.schema.PointOwnConfig.date_format","title":"<code>date_format = 'ISO8601'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Format to parse dates - will be used if T column is provided</p>"},{"location":"schema/#core.point.schema.PointOwnConfig.epsg","title":"<code>epsg = 4326</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EPSG code</p>"},{"location":"schema/#core.point.schema.PointConfig","title":"<code>PointConfig</code>","text":"<p>               Bases: <code>SourceConfig</code>, <code>PointOwnConfig</code></p> <p>Extends SourceConfig to describe point asset.</p>"},{"location":"schema/#core.point.schema.PointConfig.to_asset_config","title":"<code>to_asset_config()</code>","text":"<p>Produce a dictionary that has the signature of <code>PointOwnConfig</code></p>"},{"location":"schema/#core.raster.schema.RasterOwnConfig","title":"<code>RasterOwnConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Config that defines the minimum information for parsing and reading raster asset. This config is produced for raster asset when the method <code>to_asset_config</code> is invoked, or when <code>StacGeneratorFactory.extract_item_config</code> is called on a raster STAC Item.</p>"},{"location":"schema/#core.raster.schema.RasterOwnConfig.band_info","title":"<code>band_info</code>  <code>instance-attribute</code>","text":"<p>List of band information - REQUIRED</p>"},{"location":"schema/#core.raster.schema.RasterConfig","title":"<code>RasterConfig</code>","text":"<p>               Bases: <code>SourceConfig</code>, <code>RasterOwnConfig</code></p> <p>Extends SourceConfig to describe raster asset.</p>"},{"location":"schema/#core.raster.schema.RasterConfig.to_asset_config","title":"<code>to_asset_config()</code>","text":"<p>Produce a dictionary that has the signature of <code>RasterOwnConfig</code></p>"},{"location":"schema/#core.raster.schema.BandInfo","title":"<code>BandInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Band information for raster data</p>"},{"location":"schema/#core.raster.schema.BandInfo.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Band name. Will be converted to lower case for serialisation</p>"},{"location":"schema/#core.raster.schema.BandInfo.common_name","title":"<code>common_name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Band's common name. Users should only provide one of the supported names.</p>"},{"location":"schema/#core.raster.schema.BandInfo.wavelength","title":"<code>wavelength = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Band's wavelength</p>"},{"location":"schema/#core.raster.schema.BandInfo.nodata","title":"<code>nodata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Band's nodata value</p>"},{"location":"schema/#core.raster.schema.BandInfo.data_type","title":"<code>data_type = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Band's data_type</p>"},{"location":"schema/#core.raster.schema.BandInfo.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Band's description</p>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#setup","title":"Setup","text":"<p>This tutorial demonstrates how to use the STAC generator command-line interface to describe spatio-temporal assets. It covers various scenarios and data types.</p>"},{"location":"setup/#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Download Assets</p> <p>Download the zip file containing the raw assets for this tutorial here. Extract it into a folder named <code>Example</code>.</p> </li> <li> <p>Install STAC Generator</p> <p>Install the stac_generator package either globally or within a virtual environment.</p> </li> <li> <p>Open Terminal in <code>Example</code></p> <ul> <li>Windows: right click and select the option <code>Open in Terminal</code>.</li> <li>Mac: right click and select the option <code>New Terminal at Folder</code>.</li> <li>Linux: right click and select <code>Open in Terminal</code>.</li> </ul> </li> </ol>"},{"location":"setup/#verifying-installation","title":"Verifying Installation","text":"<p>Run the following command in the terminal to ensure the stac_generator is installed correctly:</p> <p><pre><code>stac_generator --version\n</code></pre> Expected output:</p> <p></p>"},{"location":"setup/#generating-stac-records","title":"Generating STAC Records","text":"<p>To create a STAC-compliant record, you need to provide additional metadata using configuration files. Configurations define STAC items in a collection. At a minimum, a config file should include:</p> <ul> <li><code>location</code>: path to the asset</li> <li><code>id</code>: Unique identifier</li> <li><code>collection_date</code>: date of asset collection</li> <li><code>collection_time</code>: time of asset collection</li> </ul> <p>Note that config fields can be entered in any order.</p> <p>Supported config formats:</p> <ul> <li>Preferred: json, yaml</li> <li>Limited use: csv</li> </ul> <p>Example configurations are included in the config folder of the extracted zip file.</p> <p>Note: The tutorial configs differ slightly from these due to their use of cloud-based asset URLs.</p>"},{"location":"stac_generator_architecture/","title":"STAC Generator Architecture","text":""},{"location":"stac_generator_architecture/#workflow","title":"Workflow","text":"<ol> <li> <p>I/O</p> <p>Users provides as input various configuration formats. Configurations can be paths to json/yaml config files, python dictionaries or subclasses of <code>SourceConfig</code>.</p> </li> <li> <p>Classification/Validation</p> <p>The configs are passed to <code>StacGeneratorFactory</code> which matches raw configurations to the appropriate configuration subclass - <code>RasterConfig</code>, <code>VectorConfig</code> and <code>PointConfig</code>. The matching process is performed using the config's <code>location</code> extension. The promotion step also involves data validation, which checks whether the required fields are provided.</p> </li> <li> <p>Conversion to ItemGenerator</p> <p>The <code>SourceConfig</code> instances are then promoted to an appropriate <code>ItemGenerator</code> instance (<code>RasterGenerator</code>, <code>VectorGenerator</code>, and <code>PointGenerator</code>).</p> </li> <li> <p>Instantiate CollectionGenerator</p> <p>Together with the list of <code>ItemGenerator</code> subjects, a set of collection's fields and keywords is used to instantiate the <code>CollectionGenerator</code> object.</p> </li> <li> <p>Serialisation</p> <p>Using the <code>CollectionGenerator</code> object, the STAC generator uses the <code>StacSerialiser</code> class for writing the metadata locally or to a remote API.</p> </li> </ol>"},{"location":"stac_generator_architecture/#faq","title":"FAQ","text":""},{"location":"stac_generator_architecture/#handling-of-collections-spatial-extent-attributes","title":"Handling of Collection's spatial extent attributes","text":"<p>The spatial extent is determined as enclosing bounding box of all items' bounding boxes. This bounding box is in WGS 84.</p>"},{"location":"stac_generator_architecture/#handling-of-collections-temporal-extent-attributes","title":"Handling of Collection's temporal extent attributes","text":"<p>The temporal extent is determined as the minimum <code>start_datetime</code> and the maximum <code>end_datetime</code> in UTC.</p>"},{"location":"stac_generator_architecture/#handling-of-items-geometry-attributes","title":"Handling of Item's geometry attributes","text":"<p>The item's geometry is read from the asset. If the asset's geometry is not in WGS 84 (EPSG 4326), the values are converted to WGS 84 before serialisation.</p>"},{"location":"stac_generator_architecture/#handling-of-items-bbox-attributes","title":"Handling of Item's bbox attributes","text":"<p>An item's bounding box (top, left, bottom, right) is determined from the smallest bounding box that encloses the item's geometry. The values are converted to WGS 84 before serialisation.</p>"},{"location":"stac_generator_architecture/#handling-of-items-datetime-attributes","title":"Handling of Item's datetime attributes","text":"<p>The item's datetime value is determined from the config's fields <code>collection_date</code>, <code>collection_time</code>, and <code>timezone</code>. If <code>timezone</code> is not provided or <code>timezone</code> is <code>local</code>, the data's timezone is inferred using the asset's geometry. The <code>collection_date</code> and <code>collection_time</code> are then combined and converted from the <code>timezone</code> value to <code>utc</code>.</p>"},{"location":"stac_generator_architecture/#handling-of-items-start_datetime-and-end_datetime-attributes","title":"Handling of Item's start_datetime and end_datetime attributes","text":"<p>For asset that are time-series based (either a point asset with a <code>T</code> attribute or a joined vector asset with a <code>date_column</code> in <code>join_config</code>), the date values are extracted from the asset. Any timestamp that are not timezone-awared will be assigned a timezone value based on the <code>timezone</code> config field as described previously. All timestamps are then converted to UTC. <code>start_datetime</code> and <code>end_datetime</code> are the minimum and maximum values of the UTC timestamps.</p> <p>For assets that do not contain timeseries, <code>start_datetime</code> and <code>end_datetime</code> are assigned the value of <code>datetime</code>.</p>"},{"location":"stac_generator_architecture/#handling-of-items-assets-attributes","title":"Handling of Item's assets attributes","text":"<p>Unlike a generic STAC item that can contain multiple assets, a STAC Generator generated Item contains only a single asset which has the key <code>data</code>. The asset's role is also <code>data</code>.</p>"},{"location":"stac_generator_architecture/#handling-of-items-property-attributes","title":"Handling of Item's property attributes","text":"<p>Each STAC Generator generated STAC Item contains an object under the key <code>stac_generator</code> in <code>properties</code>. The object is required for subsequent asset parsing in the <code>mccn-engine</code>.</p>"},{"location":"stac_metadata/","title":"STAC Metadata","text":"<p>STAC (SpatioTemporal Asset Catalog) metadata refers to a standardized way of describing geospatial data, such as satellite imagery, through metadata that is human-readable and machine-readable. It follows the STAC specification, which provides a structured format for organizing and searching for spatio-temporal data.</p>"},{"location":"stac_metadata/#core-components","title":"Core Components","text":"<ul> <li> <p><code>Item</code>: Represents a single spatiotemporal asset (e.g., a satellite image). It includes:</p> <ul> <li> <p><code>id</code>: item's id</p> </li> <li> <p><code>bbox</code>: item's bounding box.</p> </li> <li> <p><code>geometry</code>: spatial extent (e.g., a GeoJSON polygon).</p> </li> <li> <p><code>datetime</code>: specifies the temporal information (start/end dates for Collections).</p> </li> <li> <p><code>assets</code>: individual data files (e.g., GeoTIFFs) with additional metadata such as roles (e.g., thumbnail, data).</p> </li> </ul> </li> <li> <p><code>Collection</code>: a group of related Items with shared metadata, such as satellite images from the same mission.</p> </li> </ul>"},{"location":"stac_metadata/#extensions","title":"Extensions","text":"<p>STAC is extensible, allowing additional fields to describe specific domains or use cases. Common extensions include:</p> <ul> <li>Raster Extension: describes additional raster metadata such as sampling, scale, offset etc.</li> <li>Electro-Optical Extension: for satellite images, describing bands, cloud cover, etc.</li> <li>Projection Extension: provides a way to describe the primary asset's coordinates referencing system (CRS).</li> </ul> <p>STAC metadata is typically stored in JSON format and is widely used in platforms and services dealing with geospatial data to improve accessibility and usability.</p>"},{"location":"stac_metadata/#example-stac-metadata","title":"Example STAC Metadata","text":"ItemCollection <pre><code>{\n  \"type\": \"Feature\",\n  \"stac_version\": \"1.1.0\",\n  \"stac_extensions\": [\n    \"https://stac-extensions.github.io/projection/v2.0.0/schema.json\"\n  ],\n  \"id\": \"adelaide_airport\",\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [\n      138.5196,\n      -34.9524\n    ]\n  },\n  \"bbox\": [\n    138.5196,\n    -34.9524,\n    138.5196,\n    -34.9524\n  ],\n  \"properties\": {\n    \"timezone\": \"local\",\n    \"stac_generator\": {\n      \"column_info\": [\n        {\n          \"name\": \"daily_rain\",\n          \"description\": \"Observed daily rain fall in mm\"\n        },\n        {\n          \"name\": \"max_temp\",\n          \"description\": \"Observed daily maximum temperature in degree C\"\n        },\n        {\n          \"name\": \"min_temp\",\n          \"description\": \"Observed daily minimum temperature in degree C\"\n        },\n        {\n          \"name\": \"radiation\",\n          \"description\": \"Total incoming downward shortwave radiation on a horizontal surface MJ/sqm\"\n        },\n        {\n          \"name\": \"mslp\",\n          \"description\": \"Mean sea level pressure in hPa\"\n        }\n      ],\n      \"X\": \"longitude\",\n      \"Y\": \"latitude\",\n      \"Z\": \"elevation\",\n      \"T\": \"YYYY-MM-DD\",\n      \"epsg\": 7843\n    },\n    \"start_datetime\": \"2022-12-31T13:30:00Z\",\n    \"end_datetime\": \"2023-01-31T13:30:00Z\",\n    \"proj:code\": \"EPSG:7843\",\n    \"proj:wkt2\": \"GEOGCRS[\\\"GDA2020\\\",DATUM[\\\"Geocentric Datum of Australia 2020\\\",ELLIPSOID[\\\"GRS 1980\\\",6378137,298.257222101,LENGTHUNIT[\\\"metre\\\",1]]],PRIMEM[\\\"Greenwich\\\",0,ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],CS[ellipsoidal,3],AXIS[\\\"geodetic latitude (Lat)\\\",north,ORDER[1],ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],AXIS[\\\"geodetic longitude (Lon)\\\",east,ORDER[2],ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],AXIS[\\\"ellipsoidal height (h)\\\",up,ORDER[3],LENGTHUNIT[\\\"metre\\\",1]],USAGE[SCOPE[\\\"Geodesy, cadastre, engineering survey, topographic mapping.\\\"],AREA[\\\"Australia including Lord Howe Island, Macquarie Island, Ashmore and Cartier Islands, Christmas Island, Cocos (Keeling) Islands, Norfolk Island. All onshore and offshore.\\\"],BBOX[-60.55,93.41,-8.47,173.34]],ID[\\\"EPSG\\\",7843]]\",\n    \"datetime\": \"2022-12-31T22:30:00Z\"\n  },\n  \"links\": [\n    {\n      \"rel\": \"root\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/collection.json\",\n      \"type\": \"application/json\",\n      \"title\": \"Auto-generated.\"\n    },\n    {\n      \"rel\": \"collection\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/collection.json\",\n      \"type\": \"application/json\",\n      \"title\": \"Auto-generated.\"\n    },\n    {\n      \"rel\": \"self\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/adelaide_airport/adelaide_airport.json\",\n      \"type\": \"application/json\"\n    },\n    {\n      \"rel\": \"parent\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/collection.json\",\n      \"type\": \"application/json\",\n      \"title\": \"Auto-generated.\"\n    }\n  ],\n  \"assets\": {\n    \"data\": {\n      \"href\": \"tests/files/integration_tests/point/data/adelaide_airport.csv\",\n      \"type\": \"text/csv\",\n      \"description\": \"Raw csv data\",\n      \"roles\": [\n        \"data\"\n      ]\n    }\n  },\n  \"collection\": \"collection\"\n}\n</code></pre> <pre><code>{\n  \"type\": \"Collection\",\n  \"id\": \"collection\",\n  \"stac_version\": \"1.1.0\",\n  \"description\": \"Auto-generated\",\n  \"links\": [\n    {\n      \"rel\": \"root\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/collection.json\",\n      \"type\": \"application/json\",\n      \"title\": \"Auto-generated.\"\n    },\n    {\n      \"rel\": \"item\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/adelaide_airport/adelaide_airport.json\",\n      \"type\": \"application/geo+json\"\n    },\n    {\n      \"rel\": \"item\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/adelaide_salisbury_bowling_club/adelaide_salisbury_bowling_club.json\",\n      \"type\": \"application/geo+json\"\n    },\n    {\n      \"rel\": \"item\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/aston_coop/aston_coop.json\",\n      \"type\": \"application/geo+json\"\n    },\n    {\n      \"rel\": \"item\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/belair/belair.json\",\n      \"type\": \"application/geo+json\"\n    },\n    {\n      \"rel\": \"item\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/edinburg_raaf/edinburg_raaf.json\",\n      \"type\": \"application/geo+json\"\n    },\n    {\n      \"rel\": \"item\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/glen_osmond/glen_osmond.json\",\n      \"type\": \"application/geo+json\"\n    },\n    {\n      \"rel\": \"item\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/happy_valley_reservoir/happy_valley_reservoir.json\",\n      \"type\": \"application/geo+json\"\n    },\n    {\n      \"rel\": \"item\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/hope_valley_reservoir/hope_valley_reservoir.json\",\n      \"type\": \"application/geo+json\"\n    },\n    {\n      \"rel\": \"item\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/north_adelaide/north_adelaide.json\",\n      \"type\": \"application/geo+json\"\n    },\n    {\n      \"rel\": \"item\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/soil_data/soil_data.json\",\n      \"type\": \"application/geo+json\"\n    },\n    {\n      \"rel\": \"self\",\n      \"href\": \"/home/harry/CodingProject/stac-generator/tests/files/integration_tests/point/generated/collection.json\",\n      \"type\": \"application/json\"\n    }\n  ],\n  \"title\": \"Auto-generated.\",\n  \"extent\": {\n    \"spatial\": {\n      \"bbox\": [\n        [\n          138.5196,\n          -35.0591,\n          150.5560285,\n          -24.33600118\n        ]\n      ]\n    },\n    \"temporal\": {\n      \"interval\": [\n        [\n          \"2022-12-31T22:30:00Z\",\n          \"2023-01-08T22:30:00Z\"\n        ]\n      ]\n    }\n  },\n  \"license\": \"proprietary\"\n}\n</code></pre>"},{"location":"utility/","title":"Utility","text":""},{"location":"utility/#core.base.utils.parse_href","title":"<code>parse_href(base_url, collection_id, item_id=None)</code>","text":"<p>Generate href for collection or item based on id. This is used for generating STAC API URL.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>base url</p> required <code>collection_id</code> <code>str</code> <p>collection id</p> required <code>item_id</code> <code>str | None</code> <p>item's id. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>built url</p>"},{"location":"utility/#core.base.utils.href_is_stac_api_endpoint","title":"<code>href_is_stac_api_endpoint(href)</code>","text":"<p>Check if href points to a resource behind a stac api</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>url</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>boolean result</p>"},{"location":"utility/#core.base.utils.force_write_to_stac_api","title":"<code>force_write_to_stac_api(url, id, json)</code>","text":"<p>Force write a json object to a stac api endpoint.</p> <p>Initially try to POST the json. If 409 error encountered, will try a PUT.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>endpoint url</p> required <code>id</code> <code>str</code> <p>collection's id</p> required <code>json</code> <code>dict[str, Any]</code> <p>json body</p> required <p>Raises:</p> Type Description <code>err</code> <p>error encountered other than integrity error</p>"},{"location":"utility/#core.base.utils.read_source_config","title":"<code>read_source_config(href)</code>","text":"<p>Read in config from location</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>config location</p> required <p>Raises:</p> Type Description <code>InvalidExtensionException</code> <p>if an unrecognised extension is provided. Only accepts json, yaml, yml, csv</p> <code>StacConfigException</code> <p>if the config file cannot be read</p> <code>ConfigFormatException</code> <p>if the config is not a dictionary or a list</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: list of raw configs as dictionaries.</p>"},{"location":"utility/#core.base.utils.calculate_timezone","title":"<code>calculate_timezone(geometry)</code>","text":"<p>Method to calculate timezone string from a geometry or a sequence of geometries</p> <p>If a sequence of geometries is provided, the timezone is provided for the centroid of the sequence of geometries.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Geometry | Sequence[Geometry]</code> <p>geometry object</p> required <p>Raises:</p> Type Description <code>TimezoneException</code> <p>if timezone cannot be determined from geometry</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>timezone string</p>"},{"location":"utility/#core.base.utils.get_timezone","title":"<code>get_timezone(timezone, geometry)</code>","text":"<p>Get timezone string based on provided timezone option and geometry.</p> <p>This invokes the <code>calculate_timezone</code> method under the hood if appropriate.</p> <p>Parameters:</p> Name Type Description Default <code>timezone</code> <code>str | Literal[&amp;quot;local&amp;quot;, &amp;quot;utc&amp;quot;]</code> <p>timezone parameter from SourceConfig</p> required <code>geometry</code> <code>Geometry | Sequence[Geometry]</code> <p>asset's geometry.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>timezone string</p>"},{"location":"utility/#core.base.utils.localise_timezone","title":"<code>localise_timezone(data, tzinfo)</code>","text":"<pre><code>localise_timezone(\n    data: Timestamp, tzinfo: str\n) -&gt; Timestamp\n</code></pre><pre><code>localise_timezone(\n    data: TimeSeries, tzinfo: str\n) -&gt; TimeSeries\n</code></pre> <p>Add timezone information to data then converts to UTC</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Timestamp | TimeSeries</code> <p>series of timestamps or a single timestamp</p> required <code>tzinfo</code> <code>str</code> <p>parsed timezone</p> required <p>Raises:</p> Type Description <code>TimezoneException</code> <p>an invalid timezone is provided</p> <p>Returns:</p> Type Description <code>Timestamp | TimeSeries</code> <p>Timestamp | TimeSeries: utc localised timestamp</p>"},{"location":"utility/#core.base.utils.is_string_convertible","title":"<code>is_string_convertible(value)</code>","text":"<p>Check whether value is string or path</p> <p>If value is Path, converts to string via <code>as_posix</code></p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>input value</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>is not a string or Path</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>string path</p>"},{"location":"utility/#core.base.utils.read_point_asset","title":"<code>read_point_asset(src_path, X_coord, Y_coord, epsg, Z_coord=None, T_coord=None, date_format='ISO8601', columns=None, timezone='local')</code>","text":"<p>Read in point data from disk or remote</p> <p>Users must provide at the bare minimum the location of the csv, and the names of the columns to be treated as the X and Y coordinates. By default, will read in all columns in the csv. If columns and groupby columns are provided, will selectively read specified columns together with the coordinate columns (X, Y, T).</p> <p>Timezone information is used to convert all timestamps to timezone-aware timestamps. Timestamps that are originally timezone awared will not be affected. Timestamps that are originally non-timezone awared will be embeded with timezone information. Timestamps are subsequently converted to UTC.</p> <p>Parameters:</p> Name Type Description Default <code>src_path</code> <code>str</code> <p>source location</p> required <code>X_coord</code> <code>str</code> <p>column to be treated as the x_coordinate</p> required <code>Y_coord</code> <code>str</code> <p>column to be treated as the y coordinate</p> required <code>epsg</code> <code>int</code> <p>epsg code</p> required <code>Z_coord</code> <code>str | None</code> <p>column to be treated as the z coordinate. Defaults to None.</p> <code>None</code> <code>T_coord</code> <code>str | None</code> <p>column to be treated as timestamps. Defaults to None.</p> <code>None</code> <code>date_format</code> <code>str</code> <p>date intepretation method. Defaults to \"ISO8601\".</p> <code>'ISO8601'</code> <code>columns</code> <code>set[str] | set[ColumnInfo] | Sequence[str] | Sequence[ColumnInfo] | None</code> <p>columns to be read from the point asset. Defaults to None.</p> <code>None</code> <code>timezone</code> <code>str | Literal[&amp;quot;utc&amp;quot;, &amp;quot;local&amp;quot;]</code> <p>timezone parameter for embedding non-timezone-aware timestamps. Defaults to \"local\".</p> <code>'local'</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>gpd.GeoDataFrame: read dataframe</p>"},{"location":"utility/#core.base.utils.read_vector_asset","title":"<code>read_vector_asset(src_path, bbox=None, columns=None, layer=None)</code>","text":"<p>Read in vector asset from disk or remote.</p> <p>Users can provide an optional bbox for constraining the region of the vector data to be read, a set of columns describing the attributes of interest, and a layer parameter if the asset is a multilayered vector asset.</p> <p>Parameters:</p> Name Type Description Default <code>src_path</code> <code>str | Path</code> <p>path to asset.</p> required <code>bbox</code> <code>tuple[float, float, float, float] | None</code> <p>bbox to define the region of interest. Defaults to None.</p> <code>None</code> <code>columns</code> <code>set[str] | Sequence[str] | None</code> <p>sequence of columns to be read from the vector file. Defaults to None.</p> <code>None</code> <code>layer</code> <code>str | int | None</code> <p>layer indentifier for a multilayered asset. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>StacConfigException</code> <p>if the provided layer is non-existent</p> <code>SourceAssetException</code> <p>if the asset cannot be accessed or is malformatted</p> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>gpd.GeoDataFrame: read dataframe</p>"},{"location":"utility/#core.base.utils.read_join_asset","title":"<code>read_join_asset(src_path, right_on, date_format, date_column, columns, tzinfo)</code>","text":"<p>Read the join asset from disk or remote</p> <p>Parameters:</p> Name Type Description Default <code>src_path</code> <code>str</code> <p>path to join asset</p> required <code>right_on</code> <code>str</code> <p>right on attribute from join config</p> required <code>date_format</code> <code>str</code> <p>date format from join config</p> required <code>date_column</code> <code>str | None</code> <p>date column from join config</p> required <code>columns</code> <code>set[str] | Sequence[str] | set[ColumnInfo] | Sequence[ColumnInfo]</code> <p>list of columns to be read in from the asset</p> required <code>tzinfo</code> <code>str</code> <p>timezone information - already parsed using get_timezone</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: description</p>"},{"location":"utility/#core.base.utils.extract_epsg","title":"<code>extract_epsg(crs)</code>","text":"<p>Extract epsg information from crs object. If epsg info can be extracted directly from crs, return that value. Otherwise, try to convert the crs info to WKT2 and extract EPSG using regex</p> <p>Note that this method may yield unreliable result</p> <p>Parameters:</p> Name Type Description Default <code>crs</code> <code>CRS</code> <p>crs object</p> required <p>Returns:</p> Type Description <code>tuple[int, bool]</code> <p>tuple[int, bool]: epsg code and reliability flag</p>"},{"location":"vector_attributes/","title":"Vector - Attributes","text":"<p>In the previous tutorial, we created a bare minimum config to describe a vector asset. The generated STAC thus contains only the geometry information. In this example, we will enhance the metadata by adding more descriptive fields such as <code>title</code> and <code>description</code>. Additionally, we will describe attributes contained within the vector file. We still use the same asset <code>Werribee.json</code> in the downloaded zip file.</p> <p>For instance, the shape file <code>Werribee.geojson</code> has an attribute called <code>Suburb_Name</code>:</p> <p></p>"},{"location":"vector_attributes/#config","title":"Config","text":"jsonyaml vector_detailed_config.json<pre><code>[\n  {\n    \"id\": \"Werribee\",\n    \"location\": \"Werribee.geojson\",\n    \"collection_date\": \"2025-01-01\",\n    \"collection_time\": \"00:00:00\",\n    \"title\": \"Werribee Item\",\n    \"description\": \"Suburbs near Werribee Melbourne\",\n    \"column_info\": [\n      {\n        \"name\": \"Suburb_Name\",\n        \"description\": \"suburb name\"\n      }\n    ]\n  }\n]\n</code></pre> vector_detailed_config.yaml<pre><code>- id: \"Werribee\"\n  location: \"Werribee.geojson\"\n  collection_date: \"2025-01-01\"\n  collection_time: \"00:00:00\"\n  title: \"Werribee Item\"\n  description: \"Suburbs near Werribee Melbourne\"\n  column_info:\n    - name: \"Suburb_Name\"\n      description: \"suburb name\"\n</code></pre>"},{"location":"vector_attributes/#field-explanation","title":"Field Explanation","text":"<p>The basic fields are the same as those in the previous section. The additional fields are:</p> <ul> <li><code>title</code>: item's title</li> <li><code>description</code>: item's description</li> <li><code>column_info</code>: contains a list of column objects with attribute <code>name</code> and <code>description</code>. This field is used to represent the attributes contained in the vector file.</li> </ul> <p>STAC Common-metadata like <code>title</code> and <code>description</code> can be included in generated STAC records by adding them in the item config. Users can describe the attributes associated with the vector file through the keyword <code>column_info</code>. Users don't need to describe all attributes, but if one of the column objects provided in <code>column_info</code> is not present, the program will raise an error.</p> <p>To see a list of supported metadata, please refer to the relevant documentation.</p>"},{"location":"vector_attributes/#command-and-output","title":"Command and Output","text":"<p>Save this config as <code>vector_detailed_config.json</code>/<code>vector_detailed_config.yaml</code> in the same folder and run the serialisation command:</p> <pre><code>stac_generator serialise vector_detailed_config.json\n</code></pre> <p>The fields <code>title</code>, <code>description</code>, and <code>column_info</code> should appear correctly under the generated item's <code>properties</code>.</p>"},{"location":"vector_geometry/","title":"Vector - Geometry","text":"<p>This section focuses on describing only the geometry of a shape file (<code>.shp</code>, <code>.geojson</code>, etc). We will use the asset <code>Werribee.geojson</code> included in the downloaded zip file.</p> <p>If you have QGIS installed, you can open the file in QGIS to visualize the data:</p> <p></p>"},{"location":"vector_geometry/#config","title":"Config","text":"<p>To describe the shape file, create a configuration file named <code>vector_simple_config</code> in one of the supported formats: JSON or YAML.</p> jsonyaml vector_simple_config.json<pre><code>[\n  {\n    \"id\": \"Werribee\",\n    \"location\": \"Werribee.geojson\",\n    \"collection_date\": \"2025-01-01\",\n    \"collection_time\": \"00:00:00\"\n  }\n]\n</code></pre> vector_simple_config.yaml<pre><code>- id: \"Werribee\"\n  location: \"Werribee.geojson\"\n  collection_date: \"2025-01-01\"\n  collection_time: \"00:00:00\"\n</code></pre>"},{"location":"vector_geometry/#field-explanation","title":"Field Explanation","text":"<ul> <li><code>id</code>: the unique identifier for the item. Note that items in a collection must have unique identifiers.</li> <li><code>location</code>: the relative path to the asset file.</li> <li><code>collection_date</code>: the date the asset was collected.</li> <li><code>collection_time</code>: the time the asset was collected.</li> </ul> <p>Note that these fields are the minimum required set of fields to describe an asset as outlined previously. If <code>location</code> points to a non-existent file, or if the STAC generator cannot access the file through <code>location</code>, the program will raise an error.</p> <p>Save the file in the current directory as <code>vector_simple_config.json</code> or <code>vector_simple_config.yaml</code>.</p>"},{"location":"vector_geometry/#command-and-output","title":"Command and Output","text":"<p>Now run the stac generator serialise command from the terminal:</p> <pre><code>stac_generator serialise vector_simple_config.json\n</code></pre> <p>After running the command, a new folder named generated will appear in the current directory. Inside the generated folder, you will find:</p> <ul> <li> <p>collection.json: Contains the STAC Collection metadata.</p> </li> <li> <p>Werribee/Werribee.json: Contains the STAC Item metadata for our simple vector.</p> </li> </ul> <p>The <code>collection.json</code> and <code>Werribee.json</code> files represent the metadata for your asset, compliant with the STAC specification.</p>"},{"location":"vector_joined/","title":"Vector - Joined Attributes","text":"<p>In many spatial applications, geometry information is stored separately from attributes, typically in different tables. A join operation is performed at runtime to combine the two datasets. To simplify this workflow, we assume:</p> <ul> <li>Geometry information is extracted and stored in a vector file.</li> <li>Attributes are extracted and stored in a CSV file.</li> </ul> <p>The STAC generator can describe this join operation by including a few additional keywords in the configuration.</p>"},{"location":"vector_joined/#generic-join-asset","title":"Generic Join Asset","text":"<p>For this example, we assume the vector file <code>Werribee.geojson</code> has an accompanied attribute table stored in the file <code>distance.csv</code>.</p> Area Distance Public_Transport Drive Growth Yield Point Cook 27.3 68 50 0.046 0.04 Hoppers Crossing 30.8 67 55 0.0402 0.041 Werribee 31.3 56 50 0.0458 0.042 Werribee South 37.3 80 55 -0.01 0.04 Wyndham Vale 37.5 83 60 0.0458 0.043 Altona Meadows 23.7 61 45 0.0422 0.037 Tarneit 29.7 70 55 0.0455 0.044 <p>The asset contains some attributes associated with different suburbs near Werribee. The values of <code>Area</code> in the join asset have a 1-to-1 correspondence with the values of the attribute <code>Suburb_Name</code> in the vector asset.</p>"},{"location":"vector_joined/#config","title":"Config","text":"jsonyaml vector_join_config.json<pre><code>[\n  {\n    \"id\": \"Werribee\",\n    \"location\": \"Werribee.geojson\",\n    \"collection_date\": \"2025-01-01\",\n    \"collection_time\": \"00:00:00\",\n    \"column_info\": [\n      {\n        \"name\": \"Suburb_Name\",\n        \"description\": \"Suburb_Name\"\n      }\n    ],\n    \"join_config\": {\n      \"file\": \"distance.csv\",\n      \"left_on\": \"Suburb_Name\",\n      \"right_on\": \"Area\",\n      \"column_info\": [\n        {\n          \"name\": \"Area\",\n          \"description\": \"Area name\"\n        },\n        {\n          \"name\": \"Distance\",\n          \"description\": \"Driving Distance to CBD in km\"\n        },\n        {\n          \"name\": \"Public_Transport\",\n          \"description\": \"Time taken to reach CBD by public transport in minutes\"\n        },\n        {\n          \"name\": \"Drive\",\n          \"description\": \"Time taken to reach CBD by driving in minutes\"\n        },\n        {\n          \"name\": \"Growth\",\n          \"description\": \"Average 5 year growth in percentage in 2025\"\n        },\n        {\n          \"name\": \"Yield\",\n          \"description\": \"Average rental yield in 2025\"\n        }\n      ]\n    }\n  }\n]\n</code></pre> vector_join_config.yaml<pre><code>- id: Werribee\n  location: Werribee.geojson\n  collection_date: '2025-01-01'\n  collection_time: 00:00:00\n  column_info:\n  - description: Suburb_Name\n    name: Suburb_Name\n  join_config:\n    file: distance.csv\n    left_on: Suburb_Name\n    right_on: Area\n    column_info:\n      - description: Area Name\n        name: Area\n      - description: Driving Distance to CBD in km\n        name: Distance\n      - description: Time taken to reach CBD by public transport in minutes\n        name: Public_Transport\n      - description: Time taken to reach CBD by driving in minutes\n        name: Drive\n      - description: Average 5 year growth in percentage in 2025\n        name: Growth\n      - description: Average rental yield in 2025\n        name: Yield\n</code></pre>"},{"location":"vector_joined/#explanation-of-fields","title":"Explanation of fields","text":"<p>The first part of the config is similar to that of the previous tutorial, in which we describe the minimum required fields and the vector's attributes. We also specify the following additional fields:</p> <ul> <li><code>join_config</code>: contains metadata for the join asset</li> <li><code>file</code>: path to the join asset</li> <li><code>left_on</code>: attribute from the vector that will be used for the join operation.</li> <li><code>right_on</code>: attribute from the join asset that will be used for the join operation.</li> <li><code>column_info</code>: attributes of the join asset.</li> </ul> <p>The join terminologies that we use are consistent with pandas' merge operation's, in which the vector geometry is treated as the left dataframe, while the join asset the right dataframe. The join operation is <code>inner left join</code>, where rows with matching values of <code>left_on</code> and <code>right_on</code> are merged. Note that the field <code>left_on</code> must be described in the vector's <code>column_info</code> while <code>right_on</code> described in the join asset's <code>column_info</code>. If either of those fields are not described appropriately, an error will be raised.</p>"},{"location":"vector_joined/#command-and-output","title":"Command and Output","text":"<p>Save the config as <code>vector_join_config.json</code> and run the following command:</p> <pre><code>stac_generator serialise vector_join_config.json\n</code></pre> <p>You should see the corresponding fields appearing under <code>properties</code> in <code>Werribee.json</code>.</p>"},{"location":"vector_joined/#timeseries-join-asset","title":"Timeseries Join Asset","text":"<p>In this example, we will use the join asset <code>price.csv</code> as attributes for the vector file <code>Werribee.geojson</code>. The asset file is presented as follows:</p> Date Area Sell_Price Rent_Price Sell/Rent 2020-01-01T00:00:00Z Point Cook 630 410 1.53659 2024-01-01T00:00:00Z Point Cook 750 530 1.41509 2025-01-01T00:00:00Z Point Cook 750 560 1.33929 2020-01-01T00:00:00Z Altona Meadow 622 375 1.65867 2024-01-01T00:00:00Z Altona Meadow 727 450 1.61556 2025-01-01T00:00:00Z Altona Meadow 725 500 1.45 2020-01-01T00:00:00Z Tarneit 615 390 1.57692 2024-01-01T00:00:00Z Tarneit 690 460 1.5 2025-01-01T00:00:00Z Tarneit 700 500 1.4 2020-01-01T00:00:00Z Hoppers Crossing 510 350 1.45714 2024-01-01T00:00:00Z Hoppers Crossing 592 420 1.40952 2025-01-01T00:00:00Z Hoppers Crossing 600 450 1.33333 2020-01-01T00:00:00Z Werribee 475 345 1.37681 2024-01-01T00:00:00Z Werribee 562 400 1.405 2025-01-01T00:00:00Z Werribee 580 450 1.28889 2020-01-01T00:00:00Z Werribee South 628 385 1.63117 2024-01-01T00:00:00Z Werribee South 870 430 2.02326 2025-01-01T00:00:00Z Werribee South 595 440 1.35227 2020-01-01T00:00:00Z Wyndham Vale 448 340 1.31765 2024-01-01T00:00:00Z Wyndham Vale 530 410 1.29268 2025-01-01T00:00:00Z Wyndham Vale 532 440 1.20909 <p>The asset contains the sale and rental prices of various surburbs in Werribee over three different time periods 2020, 2024 and 2025. Similarly, the attribute <code>Area</code> of the join asset is used to perform the join operation with the attribute  <code>Suburb_Name</code> of the vector asset.</p>"},{"location":"vector_joined/#config_1","title":"Config","text":"jsonyaml vector_join_date_config.json<pre><code>[\n  {\n    \"id\": \"Werribee\",\n    \"location\": \"Werribee.geojson\",\n    \"collection_date\": \"2025-01-01\",\n    \"collection_time\": \"00:00:00\",\n    \"column_info\": [\n      {\n        \"name\": \"Suburb_Name\",\n        \"description\": \"Suburb_Name\"\n      }\n    ],\n    \"join_config\": {\n      \"file\": \"price.csv\",\n      \"left_on\": \"Suburb_Name\",\n      \"right_on\": \"Area\",\n      \"date_column\": \"Date\",\n      \"column_info\": [\n        {\n          \"name\": \"Area\",\n          \"description\": \"Area Name\"\n        },\n        {\n          \"name\": \"Sell_Price\",\n          \"description\": \"Median Sales Price in 2025\"\n        },\n        {\n          \"name\": \"Rent_Price\",\n          \"description\": \"Median Rental Price in 2025\"\n        },\n        {\n          \"name\": \"Sell/Rent\",\n          \"description\": \"Ratio of Sales Price (in $1000) over Rental Price (in $)\"\n        }\n      ]\n    }\n  }\n]\n</code></pre> vector_join_date_config.yaml<pre><code>- id: Werribee\n  collection_date: '2025-01-01'\n  collection_time: 00:00:00\n  location: Werribee.geojson\n  column_info:\n  - description: Suburb_Name\n    name: Suburb_Name\n  join_config:\n    file: price.csv\n    left_on: Suburb_Name\n    right_on: Area\n    date_column: Date\n    column_info:\n    - description: Area Name\n      name: Area\n    - description: Median Sales Price in 2025\n      name: Sell_Price\n    - description: Median Rental Price in 2025\n      name: Rent_Price\n    - description: Ratio of Sales Price (in $1000) over Rental Price (in $)\n      name: Sell/Rent\n</code></pre>"},{"location":"vector_joined/#field-explanation","title":"Field Explanation","text":"<p>The config uses the same set of fields as the config for generic join asset. The additional keyword is:</p> <ul> <li><code>date_column</code>: describes the attribute in the csv to be used as timestamps. From <code>price.csv</code>, this columns is <code>Date</code>.</li> </ul> <p>By default, date values in <code>date_column</code> will be parsed using ISO8601 date format. If date values are encoded with a custom format, the format can be provided using the field <code>date_format</code>. The date formats follows python's strptime formats. Note that if the date column cannot be found in the asset or date values cannot be parsed (either using ISO8601 or <code>date_format</code> value if provided), the program will raise an error.</p>"},{"location":"vector_joined/#command-and-output_1","title":"Command and Output","text":"<p>Save the config as <code>vector_join_date_config.json</code> and run the following command:</p> <pre><code>stac_generator serialise vector_join_date_config.json\n</code></pre> <p>The output should contain the specified fields.</p>"},{"location":"vector_multilayered/","title":"Vector - Multilayered","text":"<p>It is not uncommon to have a multiple shape files compressed into a single zip for archival. The STAC Generator provides some mechanism for handling zipped vector files without having to uncompress the file. In this tutorial, we will make use of <code>SA2.zip</code>, which contains the shape files for the Werribee and Sunbury suburbs in Victoria.</p> <p></p> <p>Here we have two layers - Sunbury and Werribee, and each layer will be generated as a STAC item with indepdent config entries. If there are multiple layers in a zip file, users can choose which layer to describe.</p>"},{"location":"vector_multilayered/#config","title":"Config","text":"jsonyaml vector_layer_config.json<pre><code>[\n  {\n    \"id\": \"WerribeeSA2\",\n    \"location\": \"SA2.zip\",\n    \"collection_date\": \"2025-01-01\",\n    \"collection_time\": \"00:00:00\",\n    \"layer\": \"Werribee\"\n  },\n  {\n    \"id\": \"SunburySA2\",\n    \"location\": \"SA2.zip\",\n    \"collection_date\": \"2025-01-01\",\n    \"collection_time\": \"00:00:00\",\n    \"layer\": \"Sunbury\"\n  }\n]\n</code></pre> vector_layer_config.yaml<pre><code>- id: WerribeeSA2\n  collection_date: '2025-01-01'\n  collection_time: 00:00:00\n  layer: Werribee\n  location: SA2.zip\n- id: SunburySA2\n  collection_date: '2025-01-01'\n  collection_time: 00:00:00\n  layer: Sunbury\n  location: SA2.zip\n</code></pre>"},{"location":"vector_multilayered/#field-explanations","title":"Field Explanations","text":"<ul> <li><code>layer</code>: the layer name in the zip file.</li> </ul> <p>Note that if layer name is not present in the zip file, the program will raise an error.</p>"},{"location":"vector_multilayered/#command-and-output","title":"Command and Output","text":"<p>Save the new config as <code>vector_layer_config.json</code> and run the command:</p> <pre><code>stac_generator serialise vector_layer_config.json\n</code></pre> <p>You will see two items generated, <code>WerribeSA2</code> and <code>SunburySA2</code>. Note that each config record has a <code>layer</code> keyword to identify the layer in the compressed zip. We use a simple config to describe each layer, but it is possible to add additional information like column info and join attributes as described in the previous sections.</p>"},{"location":"extensions/point/generator/","title":"Generator","text":""},{"location":"extensions/point/generator/#core.point.generator.PointGenerator","title":"<code>PointGenerator</code>","text":"<p>               Bases: <code>BaseVectorGenerator[PointConfig]</code></p> <p>ItemGenerator class that handles point data in csv format</p>"},{"location":"extensions/point/generator/#core.point.generator.PointGenerator.generate","title":"<code>generate()</code>","text":"<p>Generate a STAC Item based on provided point config</p> <p>Returns:</p> Type Description <code>pystac.Item</code> <p>pystac.Item: generated STAC Item</p>"},{"location":"extensions/point/schema/","title":"Schema","text":""},{"location":"extensions/point/schema/#core.point.schema.PointOwnConfig","title":"<code>PointOwnConfig</code>","text":"<p>               Bases: <code>HasColumnInfo</code></p> <p>Source config for point(csv) data. This config is produced for point asset when the method <code>to_asset_config</code> is invoked, or when <code>StacGeneratorFactory.extract_item_config</code> is called on a point STAC Item.</p>"},{"location":"extensions/point/schema/#core.point.schema.PointOwnConfig.X","title":"<code>X</code>  <code>instance-attribute</code>","text":"<p>Column to be treated as longitude/X coordinate</p>"},{"location":"extensions/point/schema/#core.point.schema.PointOwnConfig.Y","title":"<code>Y</code>  <code>instance-attribute</code>","text":"<p>Column to be treated as latitude/Y coordinate</p>"},{"location":"extensions/point/schema/#core.point.schema.PointOwnConfig.Z","title":"<code>Z = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Column to be treated as altitude/Z coordinate</p>"},{"location":"extensions/point/schema/#core.point.schema.PointOwnConfig.T","title":"<code>T = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Column to be treated as time coordinate</p>"},{"location":"extensions/point/schema/#core.point.schema.PointOwnConfig.date_format","title":"<code>date_format = 'ISO8601'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Format to parse dates - will be used if T column is provided</p>"},{"location":"extensions/point/schema/#core.point.schema.PointOwnConfig.epsg","title":"<code>epsg = 4326</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EPSG code</p>"},{"location":"extensions/point/schema/#core.point.schema.PointConfig","title":"<code>PointConfig</code>","text":"<p>               Bases: <code>SourceConfig</code>, <code>PointOwnConfig</code></p> <p>Extends SourceConfig to describe point asset.</p>"},{"location":"extensions/point/schema/#core.point.schema.PointConfig.to_asset_config","title":"<code>to_asset_config()</code>","text":"<p>Produce a dictionary that has the signature of <code>PointOwnConfig</code></p>"},{"location":"extensions/raster/generator/","title":"Generator","text":""},{"location":"extensions/raster/generator/#core.raster.generator.RasterGenerator","title":"<code>RasterGenerator</code>","text":"<p>               Bases: <code>ItemGenerator[RasterConfig]</code></p> <p>Raster Generator</p>"},{"location":"extensions/raster/generator/#core.raster.generator.RasterGenerator.generate","title":"<code>generate()</code>","text":"<p>Generate a STAC Item from RasterConfig</p> <p>Raises:</p> Type Description <code>SourceAssetException</code> <p>if the data cannot be accessed</p> <p>Returns:</p> Type Description <code>pystac.Item</code> <p>pystac.Item: generated STAC Item</p>"},{"location":"extensions/raster/schema/","title":"Schema","text":""},{"location":"extensions/raster/schema/#core.raster.schema.RasterOwnConfig","title":"<code>RasterOwnConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Config that defines the minimum information for parsing and reading raster asset. This config is produced for raster asset when the method <code>to_asset_config</code> is invoked, or when <code>StacGeneratorFactory.extract_item_config</code> is called on a raster STAC Item.</p>"},{"location":"extensions/raster/schema/#core.raster.schema.RasterOwnConfig.band_info","title":"<code>band_info</code>  <code>instance-attribute</code>","text":"<p>List of band information - REQUIRED</p>"},{"location":"extensions/raster/schema/#core.raster.schema.RasterConfig","title":"<code>RasterConfig</code>","text":"<p>               Bases: <code>SourceConfig</code>, <code>RasterOwnConfig</code></p> <p>Extends SourceConfig to describe raster asset.</p>"},{"location":"extensions/raster/schema/#core.raster.schema.RasterConfig.to_asset_config","title":"<code>to_asset_config()</code>","text":"<p>Produce a dictionary that has the signature of <code>RasterOwnConfig</code></p>"},{"location":"extensions/raster/schema/#core.raster.schema.BandInfo","title":"<code>BandInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Band information for raster data</p>"},{"location":"extensions/raster/schema/#core.raster.schema.BandInfo.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Band name. Will be converted to lower case for serialisation</p>"},{"location":"extensions/raster/schema/#core.raster.schema.BandInfo.common_name","title":"<code>common_name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Band's common name. Users should only provide one of the supported names.</p>"},{"location":"extensions/raster/schema/#core.raster.schema.BandInfo.wavelength","title":"<code>wavelength = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Band's wavelength</p>"},{"location":"extensions/raster/schema/#core.raster.schema.BandInfo.nodata","title":"<code>nodata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Band's nodata value</p>"},{"location":"extensions/raster/schema/#core.raster.schema.BandInfo.data_type","title":"<code>data_type = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Band's data_type</p>"},{"location":"extensions/raster/schema/#core.raster.schema.BandInfo.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Band's description</p>"},{"location":"extensions/vector/generator/","title":"Generator","text":""},{"location":"extensions/vector/generator/#core.vector.generator.VectorGenerator","title":"<code>VectorGenerator</code>","text":"<p>               Bases: <code>BaseVectorGenerator[VectorConfig]</code></p> <p>ItemGenerator class that handles vector data with common vector formats - i.e (shp, zipped shp, gpkg, geojson)</p>"},{"location":"extensions/vector/generator/#core.vector.generator.VectorGenerator.generate","title":"<code>generate()</code>","text":"<p>Create a STAC Item from a VectorConfig</p> <p>Raises:</p> Type Description <code>StacConfigException</code> <p>if the stac config fails a validation check</p> <p>Returns:</p> Type Description <code>pystac.Item</code> <p>pystac.Item: generated STAC Item</p>"},{"location":"extensions/vector/schema/","title":"Schema","text":""},{"location":"extensions/vector/schema/#core.vector.schema.VectorOwnConfig","title":"<code>VectorOwnConfig</code>","text":"<p>               Bases: <code>HasColumnInfo</code></p> <p>Config that defines the minimum information for parsing and reading vector asset. This config is produced for vector asset when the method <code>to_asset_config</code> is invoked, or when <code>StacGeneratorFactory.extract_item_config</code> is called on a vector STAC Item.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorOwnConfig.layer","title":"<code>layer = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vector layer for multi-layer shapefile.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorOwnConfig.join_config","title":"<code>join_config = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Config for join asset if valid available.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorOwnConfig.check_join_fields_described","title":"<code>check_join_fields_described()</code>","text":"<p>Validates that if join config is provided, the field <code>left_on</code> must be described by the vector's <code>column_info</code>. Also validates that <code>right_on</code> must be described by the join config's <code>column_info</code>.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig","title":"<code>VectorConfig</code>","text":"<p>               Bases: <code>SourceConfig</code>, <code>VectorOwnConfig</code></p> <p>Extends SourceConfig to describe vector asset.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig.to_asset_config","title":"<code>to_asset_config()</code>","text":"<p>Produce a dictionary that has the signature of <code>VectorOwnConfig</code></p>"},{"location":"extensions/vector/schema/#core.vector.schema.JoinConfig","title":"<code>JoinConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for join asset. This also contains information on how the vector asset and the join asset should be merged.</p> <p>Merge terminologies are consistent with pandas', where the vector asset is treated as the left table, and the join asset is the right table.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.JoinConfig.file","title":"<code>file</code>  <code>instance-attribute</code>","text":"<p>Path to asset. Must be a string or a Path.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.JoinConfig.left_on","title":"<code>left_on</code>  <code>instance-attribute</code>","text":"<p>Vector asset's attribute for joining.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.JoinConfig.right_on","title":"<code>right_on</code>  <code>instance-attribute</code>","text":"<p>Join asset's attribute for joining.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.JoinConfig.date_column","title":"<code>date_column = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the attribute in the join asset to be treated as timestamps.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.JoinConfig.date_format","title":"<code>date_format = 'ISO8601'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Format for intepreting timestamps. Accepted values follows strptime/strftime formats.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.JoinConfig.column_info","title":"<code>column_info</code>  <code>instance-attribute</code>","text":"<p>List of join asset column attribute. Note that for join assset, this cannot be empty.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.JoinConfig.check_non_empty_column_info","title":"<code>check_non_empty_column_info(value)</code>  <code>classmethod</code>","text":"<p>Method to validate that column info is non empty</p>"}]}