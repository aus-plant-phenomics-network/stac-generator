{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>stac_generator</code> is a command line interface (CLI) program to automatically generate STAC-compliant metadata for geospatial datasets. <code>stac_generator</code> provides the following features:</p> <ul> <li> <p>Generating STAC descriptions for raster (tif), vector (shp, geojson, zip+shp), and point data (csv, txt).</p> </li> <li> <p>Saving generated STAC records locally as jsons or POST/PUT them to a STAC compliant API server.</p> </li> <li> <p>Generating compliant metadata for datacube construction with the MCCN engine.</p> </li> </ul> <p>Using the STAC generator to describe a dataset is the first step in building a datacube with the MCCN engine.</p> <p>While most STAC information can be derived directly from the data, other information such as licensing, instrumentation, and ids (collection id/item id) does not come with the data and must be provided along side. We make the distinction between the following types of metadata:</p> <ul> <li> <p>STAC Collection Metadata: metadata at the collection level. Collection level metadata is provided as input in the CLI.</p> </li> <li> <p>STAC Item Metadata: metadata at the item level. Item level metadata is provided as row/entry in the metadata file.</p> </li> </ul>"},{"location":"#workflow","title":"Workflow","text":"<p>The process for generating STAC descriptions for a dataset is as follows:</p> <ul> <li> <p>Prepare assets:</p> </li> <li> <p>Determine what assets (tif images, vector boundaries, csv records) are important for the project. For instance, this can be all raw/processed data used in the project. Alternatively, this includes all data you want to load into the data cube.</p> </li> <li> <p>Host required assets somewhere with a semi-permanent URI. In general, if you want the data to be publicly accessible, the assets should be hosted on some cloud object storage - i.e S3, Nectar, etc. Otherwise, the asset only needs to be hosted somewhere accessible by the machine running the STAC Generator.</p> </li> <li> <p>Prepare Item level metadata:</p> </li> <li> <p>Depending on whether the data item is raster/vector/point, the corresponding documentations can be useful. At the very least, you should think about the item id, asset location - i.e the link to where the asset is hosted, and the date and time when the item was collected.</p> </li> <li> <p>Prepare Collection level metadata:</p> </li> <li> <p>The relevant documentation page (to be added) may be helpful. At the very least, collection id needs to be provided.</p> </li> <li> <p>Determine whether to save the STAC records locally or remotely.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Requirements: python3.10+</p> <p>STAC Generator can be installed directly from Pypi:</p> <pre><code>pip install stac_generator\n</code></pre> <p>Note that if you want STAC Generator to be accessible from everywhere (outside the environment where it is installed), you can install STAC Generator with pipx instead of pip. To install pipx, visit this.</p> <pre><code>pipx install stac_generator\n</code></pre>"},{"location":"case_studies/","title":"Case Studies","text":""},{"location":"case_studies/#quickstart","title":"Quickstart","text":"<p>In the following tutorial, we will use <code>stac_generator</code> to describe a combination of set of vector data. The vector data contains LGA data in geopackage format, soil exposure as a geojson, soil subgroup as a zip compressed shape file. The generated metadata is a STAC collection with each dataset as a STAC item.</p>"},{"location":"case_studies/#creating-a-configuration-file","title":"Creating a configuration file","text":"<p>Some spatial data types like vector are self-describing with well-understood structure adhering to some specifications. Others like csv point data are not. As such, the <code>stac_generator</code> requires additional external metadata provided in the form of a configuration file. At the bear minimum, each entry in the configuration file must have an <code>id</code> field that corresponds to the <code>id</code> of the generated item, and a <code>location</code> field that describes where the raw data is stored. Each data type may have additional requirements for processing the raw data file. For more information, please visit the schema page for each extension in the navigation bar.</p> <p>For our example, we will use the following vector_config.json:</p> <pre><code>[\n  {\n    \"id\": \"lga\",\n    \"location\": \"https://object-store.rc.nectar.org.au/v1/AUTH_2b454f47f2654ab58698afd4b4d5eba7/mccn-test-data/documentation/lga.gpkg\",\n    \"collection_date\": \"2023-04-01\",\n    \"collection_time\": \"09:00:00\",\n    \"epsg\": 3857\n  },\n  {\n    \"id\": \"soil_exposure\",\n    \"title\": \"soil exposure data - DEWNR Soil and Land Program\",\n    \"location\": \"https://object-store.rc.nectar.org.au/v1/AUTH_2b454f47f2654ab58698afd4b4d5eba7/mccn-test-data/documentation/soil_exposure.geojson\",\n    \"collection_date\": \"2016-06-09\",\n    \"collection_time\": \"09:00:00\",\n    \"epsg\": 7844\n  },\n  {\n    \"id\": \"soil_subgroup\",\n    \"title\": \"soil subgroup data - DEWNR Soil and Land Program\",\n    \"location\": \"https://object-store.rc.nectar.org.au/v1/AUTH_2b454f47f2654ab58698afd4b4d5eba7/mccn-test-data/documentation/soil_subgroup.zip\",\n    \"collection_date\": \"2016-06-09\",\n    \"collection_time\": \"09:00:00\",\n    \"epsg\": 1168\n  }\n]\n\n</code></pre> <p>In this example, the raw data (shape/geojson/gpkg) files are stored in a remote location. If you have files stored locally, you can also set the <code>location</code> field to point to the raw data.</p> <p>Users can also use a csv for configuration. The equivalent config in csv format can be found here.</p>"},{"location":"case_studies/#saving-the-stac-records","title":"Saving the STAC records","text":"<p>Once the configuration file is created, users can save the records to a local directory on disk, or to push to a STAC API endpoint.</p> <pre><code>stac_generator &lt;config_path&gt; --dst &lt;save_path&gt; --id &lt;collection_id&gt;\n</code></pre> <p>For instance, if I want to create the collection <code>vector_data</code> to <code>example/generated</code> with the <code>vector_config.json</code> config in the current directory, I can run the following:</p> <pre><code>stac_generator vector_config.json --dst example/generated --id vector_data\n</code></pre> <p>For saving to a remote API endpoint:</p> <pre><code>stac_generator vector_config.json --dst http://115.146.84.224:8082 --id vector_data\n</code></pre>"},{"location":"generator/","title":"Generator","text":""},{"location":"generator/#stac_generator.base.generator.CollectionGenerator","title":"<code>CollectionGenerator</code>","text":"<p>CollectionGenerator class. User should not need to subclass this class unless greater control over how collection is generated from items is needed.</p>"},{"location":"generator/#stac_generator.base.generator.CollectionGenerator.__init__","title":"<code>__init__(collection_cfg, generators)</code>","text":"<p>CollectionGenerator - generate collection from generators attribute</p> <p>Parameters:</p> Name Type Description Default <code>collection_cfg</code> <code>StacCollectionConfig</code> <p>collection metadata</p> required <code>generators</code> <code>Sequence[ItemGenerator]</code> <p>sequence of ItemGenerator subclasses.</p> required"},{"location":"generator/#stac_generator.base.generator.CollectionGenerator.spatial_extent","title":"<code>spatial_extent(items)</code>  <code>staticmethod</code>","text":"<p>Extract a collection's spatial extent based on geometry information of its items</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Sequence[pystac.Item]</code> <p>a list of children items in the collection</p> required <p>Returns:</p> Type Description <code>pystac.SpatialExtent</code> <p>a bbox enveloping all items</p>"},{"location":"generator/#stac_generator.base.generator.CollectionGenerator.temporal_extent","title":"<code>temporal_extent(items)</code>  <code>staticmethod</code>","text":"<p>Extract a collection's temporal extent based on time information of its items</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Sequence[pystac.Item]</code> <p>a list of children items in the collection</p> required <p>Returns:</p> Type Description <code>pystac.TemporalExtent</code> <p>[start_time, end_time] enveloping all items</p>"},{"location":"generator/#stac_generator.base.generator.CollectionGenerator.create_collection","title":"<code>create_collection()</code>","text":"<p>Generate collection from all gathered items</p> <p>Spatial extent is the bounding box enclosing all items Temporal extent is the time interval enclosing temporal extent of all items. Note that this value is automatically calculated and provided temporal extent fields (start_datetime, end_datetime) at collection level will be ignored</p> <p>Returns:</p> Type Description <code>pystac.Collection</code> <p>generated collection</p>"},{"location":"generator/#stac_generator.base.generator.ItemGenerator","title":"<code>ItemGenerator</code>","text":"<p>               Bases: <code>abc.ABC</code>, <code>Generic[T]</code></p> <p>Base ItemGenerator object. Users should extend this class for handling different file extensions.</p>"},{"location":"generator/#stac_generator.base.generator.ItemGenerator.source_type","title":"<code>source_type: type[T]</code>  <code>instance-attribute</code>","text":"<p>SourceConfig subclass that contains information used for parsing the source file</p>"},{"location":"generator/#stac_generator.base.generator.ItemGenerator.__init__","title":"<code>__init__(configs)</code>","text":"<p>Base ItemGenerator object. Users should extend this class for handling different file extensions.</p> <p>Parameters:</p> Name Type Description Default <code>configs</code> <code>list[dict[str, Any]]</code> <p>source data configs - either from csv config or yaml/json</p> required"},{"location":"generator/#stac_generator.base.generator.ItemGenerator.create_item_from_config","title":"<code>create_item_from_config(source_cfg)</code>  <code>abstractmethod</code>","text":"<p>Abstract method that handles <code>pystac.Item</code> generation from the appropriate config</p>"},{"location":"generator/#stac_generator.base.generator.ItemGenerator.create_items","title":"<code>create_items()</code>","text":"<p>Generate STAC Items from <code>configs</code> metadata</p> <p>Returns:</p> Type Description <code>list[pystac.Item]</code> <p>list of generated STAC Item</p>"},{"location":"generator/#stac_generator.base.generator.VectorGenerator","title":"<code>VectorGenerator</code>","text":"<p>               Bases: <code>ItemGenerator[T]</code></p>"},{"location":"generator/#stac_generator.base.generator.VectorGenerator.geometry","title":"<code>geometry(df)</code>  <code>staticmethod</code>","text":"<p>Calculate the geometry from geopandas dataframe.</p> <p>If geopandas dataframe has only one item, the geometry will be that of the item. If geopandas dataframe has less than 10 items of the same type, the geometry will be the Multi version of the type. Note that MultiPoint will be unpacked into points for the 10 items limit. If there are more than 10 items of the same type or there are items of different types i.e. Point and LineString, the returned geometry will be the Polygon of the bounding box. Note that Point and MultiPoint are treated as the same type (so are type and its Multi version).</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>gpd.GeoDataFrame</code> <p>input dataframe</p> required"},{"location":"generator/#stac_generator.base.generator.VectorGenerator.df_to_item","title":"<code>df_to_item(df, assets, source_cfg, properties, epsg=4326)</code>  <code>staticmethod</code>","text":"<p>Convert geopandas dataframe to pystac.Item</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>gpd.GeoDataFrame</code> <p>input dataframe</p> required <code>assets</code> <code>dict[str, pystac.Asset]</code> <p>source data asset_</p> required <code>source_cfg</code> <code>SourceConfig</code> <p>config</p> required <code>properties</code> <code>dict[str, Any]</code> <p>pystac Item properties</p> required <code>time_col</code> <code>str | None, optional</code> <p>time_col if there are time information in the input df, defaults to None</p> required <code>epsg</code> <code>int</code> <p>epsg information, defaults to 4326</p> <code>4326</code> <p>Returns:</p> Type Description <code>pystac.Item</code> <p>generated pystac Item</p>"},{"location":"generator/#stac_generator.base.generator.StacSerialiser","title":"<code>StacSerialiser</code>","text":""},{"location":"generator/#stac_generator.base.generator.StacSerialiser.pre_serialisation_hook","title":"<code>pre_serialisation_hook(collection, href)</code>  <code>staticmethod</code>","text":"<p>Hook that can be overwritten to provide pre-serialisation functionality. By default, this normalises collection href and performs validation</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>pystac.Collection</code> <p>collection object</p> required <code>href</code> <code>str</code> <p>serialisation href</p> required"},{"location":"generator/#stac_generator.base.generator.StacSerialiser.to_json","title":"<code>to_json()</code>","text":"<p>Generate STAC Collection and save to disk as json files</p>"},{"location":"generator/#stac_generator.base.generator.StacSerialiser.to_api","title":"<code>to_api()</code>","text":"<p>_Generate STAC Collection and push to remote API. The API will first attempt to send a POST request which will be replaced with a PUT request if a 409 error is encountered</p>"},{"location":"metadata/","title":"Metadata","text":""},{"location":"metadata/#data-types","title":"Data Types","text":"<p><code>stac_generator</code> classifies assets into <code>raster</code>, <code>vector</code>, and <code>point</code> data, using terminologies consistent with common GIS softwares. In general:</p> <ul> <li>Point data contains one or more entries where each entry has the <code>X</code> and <code>Y</code> fields describing the location. Each entry usually contains other fields describing the attributes at the point location. For instance, this can be soil sample measurements or raw instrument readings at a particular coordinate. Point data can also have a field representing depth/elevation or time.</li> <li>Vector data contains a collection of points whose relationship is determined by the vector type - (point, multipoint, line, multiline, polygon, multipolygon, etc). Vector data are usually shape files describing a plot or a field boundary, but can also contain plot level attributes - i.e. mean elevation, mean temperature, cumulative rainfall, etc.</li> <li>Raster data contains several 2D layers (called bands) where each band represents the attribute value at each (x, y) coordinate in the 2D grid. For instance, an orthomosaic contains RGB bands, where each band is a 2D matrix with value between 0 and 255.</li> </ul>"},{"location":"metadata/#supported-formats-for-data-assets","title":"Supported Formats for data assets:","text":"<ul> <li>Raster:<ul> <li>tif</li> <li>geotif</li> </ul> </li> <li>Vector:<ul> <li>shp</li> <li>geojson</li> <li>zip+shp</li> <li>geopkg</li> </ul> </li> <li>Point:<ul> <li>csv</li> <li>txt</li> </ul> </li> </ul> <p>Note that in some cases, plot or field level attributes are recorded in a csv that does not contain X and Y columns but a plot or field ID column referencing the same attribute in a separate vector file. In this particular example, the csv should be treated as a vector rather than a point data. We have also provided a utility tool (To be added) to denormalise the vector/csv combination into a single vector file.</p>"},{"location":"metadata/#collection-metadata","title":"Collection metadata","text":"<p>Aside from <code>datetime</code>, <code>start_datetime</code>, <code>end_datetime</code>, collection metadata contains fields described in STAC Common Metadata. In general, the most important fields are <code>id</code> (required), <code>keywords</code> (optional - can be useful for catalog filtering feature in the future), <code>license</code> (optional - licensing information).</p> <p>For a more detailed list of all fields, their data types, and default values, please refer to <code>STACCollectionConfig</code> under this link.</p>"},{"location":"metadata/#item-metadata","title":"Item metadata","text":"<p>Item metadata contains all fields in collection metadata and additional required <code>collection_date</code> and <code>collection_time</code> fields describing when the item was collected. Item metadata must also specify the <code>location</code> field, that points to where the data asset is stored.</p> <p>For a more detailed list of all fields, their data types, and default values, please refer to <code>STACItemConfig</code> and <code>SourceConfig</code> under this link.</p>"},{"location":"metadata/#point-metadata","title":"Point metadata","text":"<p>Point metadata contains all fields in item metadata (inherits from <code>SourceConfig</code>) and contains additional fields specifying how to process the given csv/txt file. This includes the <code>X</code> and <code>Y</code> fields specifying the columns to be treated as the X and Y coordinates, the <code>epsg</code> code specifying the CRS of the XY coordinates, and if the csv contains columns to be treated as depth/elevation or time, the optional <code>Z</code>, <code>T</code> and <code>time_format</code> fields.</p> <p>Users should also specify useful columns under <code>column_info</code> (please see <code>ColumnInfo</code> and <code>HasColumnInfo</code> under this link). For a more detailed list of all fields, their data types, and default values, please refer to <code>CSVConfig</code> under this link.</p>"},{"location":"metadata/#vector-metadata","title":"Vector metadata","text":"<p>Vector metadata contains all fields in item metadata (inherits from <code>SourceConfig</code>). Since vector data is often self-described, vector metadata only requires the <code>epsg</code> code for sanity checking - i.e. to ensure that users know whether they are providing the right asset. If the vector data is a compressed zip file with multiple shp files, a <code>layer</code> field is needed to specify which <code>shp</code> file in the zip package the metadata is describing. If the vector data contains plot or field level attributes, the <code>column_info</code> should also be used.</p> <p>Users should also specify useful columns under <code>column_info</code> (please see <code>ColumnInfo</code> and <code>HasColumnInfo</code> under this link). For a more detailed list of all fields, their data types, and default values, please refer to <code>VectorConfig</code> under this link.</p>"},{"location":"metadata/#raster-metadata","title":"Raster metadata","text":"<p>Raster metadata contains all fields in item metadata (inherits from <code>SourceConfig</code>). The only extra fields in raster metadata are <code>epsg</code> code and <code>band_info</code>.</p> <p>For a more detailed list of all fields, their data types, and default values, please refer to <code>RasterConfig</code> under this link.</p>"},{"location":"metadata/#representing-item-metadata-in-a-separate-metadata-file","title":"Representing Item metadata in a separate metadata file","text":"<p>Item metadata can be provided as entry/row in the metadata to be provided in the CLI. Please refer to case studies for more examples.</p>"},{"location":"schema/","title":"Schema","text":""},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig","title":"<code>StacCollectionConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains parameters to pass to Collection constructor. Also contains other metadata except for datetime related metadata.</p> <p>Collection's datetime, start_datetime and end_datetime will be derived from the time information of its children items</p> <p>This config provides additional information that can not be derived from source file, which includes Stac Common Metadata and other descriptive information such as the id of the new entity</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>Item id</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.title","title":"<code>title: str | None = 'Auto-generated Stac Item'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A human readable title describing the item entity.</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.description","title":"<code>description: str | None = 'Auto-generated Stac Item'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Detailed multi-line description to fully explain the STAC entity.</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.license","title":"<code>license: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>License(s) of the data as SPDX License identifier, SPDX License expression, or other</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.providers","title":"<code>providers: list[Provider] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of providers, which may include all organizations capturing or processing the data or the hosting provider. Providers should be listed in chronological order with the most recent provider being the last element of the list.</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.platform","title":"<code>platform: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique name of the specific platform to which the instrument is attached.</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.instruments","title":"<code>instruments: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of instrument or sensor used (e.g., MODIS, ASTER, OLI, Canon F-1).</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.constellation","title":"<code>constellation: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the constellation to which the platform belongs.</p>"},{"location":"schema/#stac_generator.base.schema.StacCollectionConfig.mission","title":"<code>mission: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the mission for which data is collected.</p>"},{"location":"schema/#stac_generator.base.schema.StacItemConfig","title":"<code>StacItemConfig</code>","text":"<p>               Bases: <code>StacCollectionConfig</code></p> <p>Contains parameters to pass to Item constructor. Also contains other metadata except for datetime related metadata.</p> <p>Item's datetime will be superseded by <code>collection_date</code> and <code>collection_time</code> recorded in local timezone. The STAC <code>datetime</code> metadata is obtained from the method <code>get_datetime</code> by providing the local timezone, which will be automatically derived from the crs information.</p> <p>This config provides additional information that can not be derived from source file, which includes Stac Common Metadata and other descriptive information such as the id of the new entity</p>"},{"location":"schema/#stac_generator.base.schema.StacItemConfig.collection_date","title":"<code>collection_date: datetime.date</code>  <code>instance-attribute</code>","text":"<p>Date in local timezone of when the data is collected</p>"},{"location":"schema/#stac_generator.base.schema.StacItemConfig.collection_time","title":"<code>collection_time: datetime.time</code>  <code>instance-attribute</code>","text":"<p>Time in local timezone of when the data is collected</p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig","title":"<code>SourceConfig</code>","text":"<p>               Bases: <code>StacItemConfig</code></p> <p>Base source config that should be subclassed for different file extensions.</p> <p>Source files contain raw spatial information (i.e. geotiff, shp, csv) from which some Stac metadata can be derived. SourceConfig describes:</p> <ul> <li>The access mechanisms for the source file: stored on local disk, or hosted somewhere behind an api endpoint. If the source file must be accessed through an endpoint, users can provide additional HTTP information that forms the HTTP request to the host server.</li> <li>Processing information that are unique for the source type. Users should inherit <code>SourceConfig</code> for file extensions currently unsupported.</li> <li>Additional Stac Metadata from <code>StacConfig</code></li> </ul>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.location","title":"<code>location: str</code>  <code>instance-attribute</code>","text":"<p>Asset's href</p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.extension","title":"<code>extension: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Explicit file extension specification. If the file is stored behind an api endpoint, the field <code>extension</code> must be provided</p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.method","title":"<code>method: HTTPMethod | None = 'GET'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTPMethod to acquire the file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.params","title":"<code>params: QueryParamTypes | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query params for getting file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.headers","title":"<code>headers: HeaderTypes | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query headers for getting file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.cookies","title":"<code>cookies: CookieTypes | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query cookies for getting file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.content","title":"<code>content: RequestContent | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.data","title":"<code>data: RequestData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.SourceConfig.json_body","title":"<code>json_body: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"schema/#stac_generator.base.schema.ColumnInfo","title":"<code>ColumnInfo</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict description of GeoDataFrame columns. Used for describing vector/point attributes</p>"},{"location":"schema/#stac_generator.base.schema.ColumnInfo.name","title":"<code>name: Required[str]</code>  <code>instance-attribute</code>","text":"<p>Column name</p>"},{"location":"schema/#stac_generator.base.schema.ColumnInfo.description","title":"<code>description: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Column description</p>"},{"location":"schema/#stac_generator.base.schema.ColumnInfo.dtype","title":"<code>dtype: NotRequired[DTYPE]</code>  <code>instance-attribute</code>","text":"<p>Column data type</p>"},{"location":"schema/#stac_generator.base.schema.HasColumnInfo","title":"<code>HasColumnInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"schema/#stac_generator.base.schema.HasColumnInfo.column_info","title":"<code>column_info: list[ColumnInfo] | list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of attributes associated with point/vector data</p>"},{"location":"schema/#stac_generator.base.schema.HasColumnInfo.coerce_to_object","title":"<code>coerce_to_object(v)</code>  <code>classmethod</code>","text":"<p>Convert json serialised string of column info into matched object</p>"},{"location":"utils/","title":"Utility","text":""},{"location":"utils/#stac_generator.base.utils.parse_href","title":"<code>parse_href(base_url, collection_id, item_id=None)</code>","text":"<p>Generate href for collection or item based on id</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>path to catalog.</p> required <code>collection_id</code> <code>str</code> <p>collection id</p> required <code>item_id</code> <code>str | None</code> <p>item id, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>uri to collection or item</p>"},{"location":"utils/#stac_generator.base.utils.href_is_stac_api_endpoint","title":"<code>href_is_stac_api_endpoint(href)</code>","text":"<p>Check if href points to a resource behind a stac api</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>path to resource</p> required <p>Returns:</p> Type Description <code>bool</code> <p>local or non-local</p>"},{"location":"utils/#stac_generator.base.utils.force_write_to_stac_api","title":"<code>force_write_to_stac_api(url, id, json)</code>","text":"<p>Force write a json object to a stac api endpoint. This function will try sending a POST request and if a 409 error is encountered, try sending a PUT request. Other exceptions if occured will be raised</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>path to stac resource for creation/update</p> required <code>json</code> <code>dict[str, Any]</code> <p>json object</p> required"},{"location":"utils/#stac_generator.base.utils.calculate_timezone","title":"<code>calculate_timezone(geometry)</code>","text":"<p>Calculate timezone from geometry</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Geometry</code> <p>geometry object in EPSG:4326 crs</p> required <p>Returns:</p> Type Description <code>str</code> <p>timezone string</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>very exceptional cases where tzfinder cannot determine timezone</p>"},{"location":"extensions/point/generator/","title":"Generator","text":""},{"location":"extensions/point/generator/#stac_generator.point.generator.PointGenerator","title":"<code>PointGenerator</code>","text":"<p>               Bases: <code>VectorGenerator[CsvConfig]</code></p> <p>ItemGenerator class that handles point data in csv format</p>"},{"location":"extensions/point/generator/#stac_generator.point.generator.PointGenerator.create_item_from_config","title":"<code>create_item_from_config(source_cfg)</code>","text":"<p>Create item from source csv config</p> <p>Parameters:</p> Name Type Description Default <code>source_cfg</code> <code>CsvConfig</code> <p>config which contains csv metadata</p> required <p>Returns:</p> Type Description <code>pystac.Item</code> <p>stac metadata of the item described in source_cfg</p>"},{"location":"extensions/point/generator/#stac_generator.point.generator.read_csv","title":"<code>read_csv(src_path, X_coord, Y_coord, epsg, Z_coord=None, T_coord=None, date_format='ISO8601', columns=None)</code>","text":"<p>Read in csv from local disk</p> <p>Users must provide at the bare minimum the location of the csv, and the names of the columns to be treated as the X and Y coordinates. By default, will read in all columns in the csv. If columns and groupby columns are provided, will selectively read specified columns together with the coordinate columns (X, Y, T).</p> <p>Parameters:</p> Name Type Description Default <code>src_path</code> <code>str</code> <p>path to csv file</p> required <code>X_coord</code> <code>str</code> <p>name of X field</p> required <code>Y_coord</code> <code>str</code> <p>name of Y field</p> required <code>epsg</code> <code>int</code> <p>epsg code</p> required <code>Z_coord</code> <code>str | None</code> <p>name of Z field</p> <code>None</code> <code>T_coord</code> <code>str | None</code> <p>name of time field, defaults to None</p> <code>None</code> <code>date_format</code> <code>str</code> <p>format to pass to pandas to parse datetime, defaults to \"ISO8601\"</p> <code>'ISO8601'</code> <code>columns</code> <code>list[str] | list[ColumnInfo] | None</code> <p>band information, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>read dataframe</p>"},{"location":"extensions/point/schema/","title":"Schema","text":""},{"location":"extensions/point/schema/#stac_generator.point.schema.CsvConfig","title":"<code>CsvConfig</code>","text":"<p>               Bases: <code>SourceConfig</code>, <code>HasColumnInfo</code></p> <p>Source config for point(csv) data</p>"},{"location":"extensions/point/schema/#stac_generator.point.schema.CsvConfig.X","title":"<code>X: str</code>  <code>instance-attribute</code>","text":"<p>Column to be treated as longitude/X coordinate</p>"},{"location":"extensions/point/schema/#stac_generator.point.schema.CsvConfig.Y","title":"<code>Y: str</code>  <code>instance-attribute</code>","text":"<p>Column to be treated as latitude/Y coordinate</p>"},{"location":"extensions/point/schema/#stac_generator.point.schema.CsvConfig.Z","title":"<code>Z: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Column to be treated as altitude/Z coordinate</p>"},{"location":"extensions/point/schema/#stac_generator.point.schema.CsvConfig.T","title":"<code>T: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Column to be treated as time coordinate</p>"},{"location":"extensions/point/schema/#stac_generator.point.schema.CsvConfig.date_format","title":"<code>date_format: str = 'ISO8601'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Format to parse dates - will be used if T column is provided</p>"},{"location":"extensions/point/schema/#stac_generator.point.schema.CsvConfig.epsg","title":"<code>epsg: int = 4326</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EPSG code</p>"},{"location":"extensions/raster/generator/","title":"Generator","text":""},{"location":"extensions/raster/schema/","title":"Schema","text":""},{"location":"extensions/raster/schema/#stac_generator.raster.schema.BandInfo","title":"<code>BandInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Band information for raster data</p>"},{"location":"extensions/raster/schema/#stac_generator.raster.schema.RasterConfig","title":"<code>RasterConfig</code>","text":"<p>               Bases: <code>SourceConfig</code></p> <p>Configuration for raster data sources</p>"},{"location":"extensions/raster/schema/#stac_generator.raster.schema.RasterConfig.epsg","title":"<code>epsg: int</code>  <code>instance-attribute</code>","text":"<p>EPSG code for the raster's coordinate reference system</p>"},{"location":"extensions/raster/schema/#stac_generator.raster.schema.RasterConfig.band_info","title":"<code>band_info: list[BandInfo]</code>  <code>instance-attribute</code>","text":"<p>List of band information - REQUIRED</p>"},{"location":"extensions/vector/generator/","title":"Generator","text":""},{"location":"extensions/vector/generator/#stac_generator.vector.generator.VectorGenerator","title":"<code>VectorGenerator</code>","text":"<p>               Bases: <code>BaseVectorGenerator[VectorConfig]</code></p> <p>ItemGenerator class that handles vector data with common vector formats - i.e (shp, zipped shp, gpkg, geojson)</p>"},{"location":"extensions/vector/generator/#stac_generator.vector.generator.VectorGenerator.create_item_from_config","title":"<code>create_item_from_config(source_cfg)</code>","text":"<p>Create item from vector config</p> <p>Parameters:</p> Name Type Description Default <code>source_cfg</code> <code>VectorConfig</code> <p>config information</p> required <p>Returns:</p> Type Description <code>pystac.Item</code> <p>stac metadata of the file described by source_cfg</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if config epsg information is different from epsg information from vector file</p>"},{"location":"extensions/vector/generator/#stac_generator.vector.generator.extract_epsg","title":"<code>extract_epsg(crs)</code>","text":"<p>Extract epsg information from crs object. If epsg info can be extracted directly from crs, return that value. Otherwise, try to convert the crs info to WKT2 and extract EPSG using regex</p> <p>Note that this method may yield unreliable result</p> <p>Parameters:</p> Name Type Description Default <code>crs</code> <code>CRS</code> <p>crs object</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>epsg information</p>"},{"location":"extensions/vector/schema/","title":"Schema","text":""},{"location":"extensions/vector/schema/#stac_generator.vector.schema.VectorConfig","title":"<code>VectorConfig</code>","text":"<p>               Bases: <code>SourceConfig</code>, <code>HasColumnInfo</code></p> <p>Extended source config with EPSG code.</p>"},{"location":"extensions/vector/schema/#stac_generator.vector.schema.VectorConfig.epsg","title":"<code>epsg: int = 4326</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EPSG code for checking against EPSG code of the vector data</p>"},{"location":"extensions/vector/schema/#stac_generator.vector.schema.VectorConfig.layer","title":"<code>layer: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vector layer for multi-layer shapefile</p>"},{"location":"metadata_examples/point/","title":"Point","text":""},{"location":"metadata_examples/point/#bom-raw-data-time-series-measurements","title":"BOM raw data (Time Series measurements)","text":"longitude latitude elevation station YYYY-MM-DD daily_rain max_temp 138.519 -34.952 2 23304 2020-01-01 0 32.2"},{"location":"metadata_examples/point/#bom-metadata-to-provide-to-the-stac-generator","title":"BOM Metadata to provide to the STAC Generator","text":"<pre><code>{\n  \"id\": \"BOM_Data\",\n  \"location\": \"path/to/bom.csv\",\n  \"collection_date\": \"2020-01-01\",\n  \"collection_time\": \"10:00:00\",\n  \"X\": \"longitude\",\n  \"Y\": \"latitude\",\n  \"Z\": \"elevation\",\n  \"T\": \"YYYY-MM-DD\",\n  \"epsg\": 4326,\n  \"column_info\": [\n    {\n      \"name\": \"daily_rain\",\n      \"description\": \"daily rain fall in mm\"\n    },\n    {\n      \"name\": \"max_temp\",\n      \"description\": \"daily maximum temperature in C\"\n    }\n  ]\n}\n</code></pre> <p>The values for id, location, collection_date, collection_time (required common metadata) are made-up. The values for X, Y, Z, T are obtained from the raw csv - i.e. longitude, latitude, elevation and YYYY-MM-DD respectively. epsg value cannot be derived from the csv and must be known by the user - i.e. reading dataset metadata on BOM/SILO website. The field column_info contains useful columns that the user want to read into the datacube.</p>"},{"location":"metadata_examples/point/#soil-raw-data-no-depth-no-timestamp","title":"Soil raw data (No depth, No Timestamp)","text":"property field profile easting northing Ca_Soln Sunbury Jordie 3 773215.36 678187.36 3"},{"location":"metadata_examples/point/#soil-metadata-to-provide-to-the-stac-generator","title":"Soil Metadata to provide to the STAC Generator","text":"<pre><code>{\n  \"id\": \"soil_data\",\n  \"location\": \"path/to/soil.csv\",\n  \"collection_date\": \"2020-01-01\",\n  \"collection_time\": \"10:00:00\",\n  \"X\": \"easting\",\n  \"Y\": \"northing\",\n  \"epsg\": 28355,\n  \"column_info\": [\n    {\n      \"name\": \"Ca_Soln\",\n      \"description\": \"Calcium solution in ppm\"\n    },\n    {\n      \"name\": \"profiles\",\n      \"description\": \"Field profile\"\n    }\n  ]\n}\n\n</code></pre> <p>The values for id, location, collection_date, collection_time (required common metadata) are made-up. The values for X, Y are obtained from the raw csv - i.e. easting and northing respectively. There is no elevation and time column so they can be left blank. The value for epsg must be known before hand, in this example, we assume it to be GDA94/MGA55 with espg code 28355. Also assuming values for property and field are not important in this example, we don\u2019t include them in column_info.</p>"},{"location":"metadata_examples/point/#ozbarley-point-data","title":"OZBarley Point Data","text":"<p>OZBarley contains 2 point assets - <code>OZBarley1_measurement</code> and <code>OZBarley2_measurement</code>. The point asset can be downloaded from the following link: OZBarley1, OZBarley2. The overall config can be downloaded here. Note that the <code>epsg</code> code is known beforehand.</p>"},{"location":"metadata_examples/point/#llaracampey-point-data","title":"LlaraCampey Point Data","text":"<p>The simplified test case for Llara Campey contains <code>soil_data.csv</code> point data. The config can be downloaded here. The asset itself can be downloaded by visiting the <code>location</code> reference under <code>soil_measurement</code> entry. The link is reproduced here for convenience.</p>"},{"location":"metadata_examples/raster/","title":"Raster","text":""},{"location":"metadata_examples/raster/#ozbarley-raster-data","title":"OZBarley Raster Data","text":"<p>OZBarley contains 6 orthomosaics covering 2 areas over 3 time periods. The dataset also contains 2 DSM tifs. The config can be downloaded here. The actual assets can be downloaded by following the <code>location</code> field in corresponding entry in the config file. Please note how the <code>band_info</code> field is used to describe the raster bands.</p>"},{"location":"metadata_examples/raster/#llaracampey-raster-data","title":"LlaraCampey Raster Data","text":"<p>Llara Campey contains 4 tifs of krigged ECa and Gamma K measurements. The config can be downloaded here. The actual assets can be downloaded by following the <code>location</code> field in the corresponding entry. Please note how the <code>band_info</code> field is used to describe the raster bands.</p>"},{"location":"metadata_examples/vector/","title":"Vector","text":""},{"location":"metadata_examples/vector/#ozbarley-vector-data","title":"OZBarley Vector Data","text":"<p>OZBarley contains 2 vector assets - <code>OZBarley1_layout</code> and <code>OZBarley2_layout</code>. The overall config can be downloaded here. The vector assets can be downloaded by following the <code>location</code> field under <code>OZBarley1_layout</code> and <code>OZBarley2_layout</code> items in the config. The links for OZBarley1 and OZBarley2 are reproduced for convenience.</p>"},{"location":"metadata_examples/vector/#llaracampey-vector-data","title":"LlaraCampey Vector Data","text":"<p>The simplified test case for Llara Campey contains the boundary shapes of different Llara and Campey plots stored as shp file in a compressed zip. To specify a particular boundary, a layer field must be provided. For more information, please refer to the config. Note how C1, C2, ... layout files all reference the same zip, with <code>layer</code> being the differentiator. Also note that while OZBarley vector files have associated attributes that are described with <code>column_info</code>, the vector files for LlaraCampey are simple shape files with no attribute (and thus do not contain <code>column_info</code>).</p>"}]}