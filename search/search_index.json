{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>STAC is a json-based metadata standard for describing spatial-temporal assets, particularly satellite and Earth observation data. STAC allows users to quickly search, discover and use geospatial assets by providing a consistent structure for query and storage.</p> <p><code>stac_generator</code> is a command line interface (CLI) program that combines automatically extracted geospatial information from raw assets and other user-provided metadata to build a STAC-compliant metadata record for further use. Generated STAC records can be saved locally or behind a STAC API-compliant server.</p> <p>The <code>stac_generator</code> was developed as part of the Multiscalar Crop Characterisation Project (MCCN). Using the STAC generator to describe an asset collection is the first step in building a datacube with the MCCN engine.</p>"},{"location":"#installation","title":"Installation","text":"<p>Requirements: python3.11-3.12</p> <p>STAC Generator can be installed directly from Pypi:</p> <pre><code>pip install pystac-generator\n</code></pre> <p>Note that if you want STAC Generator to be accessible from everywhere (outside the environment where it is installed), you can install STAC Generator with pipx instead of pip. To install pipx, visit this.</p> <pre><code>pipx install pystac-generator\n</code></pre>"},{"location":"advanced_quick_start/","title":"Advanced Quickstart","text":""},{"location":"advanced_quick_start/#using-stac_generator-as-a-python-module","title":"Using <code>stac_generator</code> as a python module","text":"<p>In the previous tutorial, we have seen how <code>stac_generator</code> can be used as a command line tool to generate STAC metadata. In this section, we will demonstrate how to write a Python script that imports the <code>stac_generator</code> modules and perform tasks in the previous section: </p> PYTHON <pre><code>import datetime\n\nfrom stac_generator.core.base import (\n    StacCollectionConfig,\n    StacSerialiser,\n)\nfrom stac_generator.core.raster import RasterConfig\nfrom stac_generator.core.vector import VectorConfig\nfrom stac_generator.factory import StacGeneratorFactory\n\n# CSV Config - Instantiate the config using a dictionary\npoint_config = {\n    \"id\": \"soil_data\",\n    \"location\": \"soil.csv\",\n    \"collection_date\": \"2020-01-01\",\n    \"collection_time\": \"10:00:00\",\n    \"X\": \"eastings_utm\",\n    \"Y\": \"northings_utm\",\n    \"epsg\": 28355,\n    \"column_info\": [\n        {\"name\": \"ca_soln\", \"description\": \"Calcium solution in ppm\"},\n        {\"name\": \"profile\", \"description\": \"Field profile\"},\n    ],\n}\n\n\n# Raster Config - Instantiate using a known config class\nraster_config = RasterConfig(\n    id=\"l2a_pvi\",\n    location=\"L2A_PVI.tif\",\n    collection_date=datetime.date(year=2020, month=1, day=1),\n    collection_time=datetime.time(hour=0, minute=0, second=0),\n    band_info=[\n        {\n            \"name\": \"B04\",\n            \"common_name\": \"red\",\n            \"description\": \"Common name: red, Range: 0.6 to 0.7\",\n            \"wavelength\": 0.6645,\n        },\n        {\n            \"name\": \"B03\",\n            \"common_name\": \"green\",\n            \"description\": \"Common name: green, Range: 0.5 to 0.6\",\n            \"wavelength\": 0.56,\n        },\n        {\n            \"name\": \"B02\",\n            \"common_name\": \"blue\",\n            \"description\": \"Common name: blue, Range: 0.45 to 0.5\",\n            \"wavelength\": 0.4966,\n        },\n    ],\n)\n\n# Vector Config - Instantiate using a file - provides a file path\nvector_config = \"vector_detailed_config.json\"\n\n# Collection Config\ncollection_config = StacCollectionConfig(\n    id=\"collection\",\n    title=\"tutorial collection\",\n    description=\"collection generated using apis instead of CLI\",\n    license=\"MIT\",\n)\n\n# Create generator\ngenerator = StacGeneratorFactory.get_stac_generator(\n    source_configs=[raster_config, vector_config, point_config],\n    collection_config=collection_config,\n)\n# Serialise collection\nserialiser = StacSerialiser(generator, \"generated\")\nserialiser()\n</code></pre> <p>The steps include: </p> <ul> <li>Declaring item configs</li> <li>Declaring collection config </li> <li>Creating a generator object by passing the item configs and collection configs to <code>StacGeneratorFactor.get_stac_generator</code>.</li> <li>Creating the serialiser object with <code>StacSerialiser</code> and call the object. </li> </ul>"},{"location":"advanced_quick_start/#declaring-item-configs","title":"Declaring item configs","text":"<p>The first step is to prepare the config. In general, there are three ways to declare a config:</p> <ul> <li>Using a config file.</li> <li>Using a regular python dictionary. </li> <li>Using a known config class. </li> </ul> <p>To declare the config from a file, you will need to provide the path to the config file that can be accessed in the current path. For instance, in the previous example, we use vector_detailed_config.json as the vector config. </p> <p>To declare the config using a dictionary, you will need to write a python dictionary with the necessary fields declared. Note how the python dictionary in the previous example has the exact same content as the config in the previous tutorial. </p> <p>Using a known config class in the recommended approach. If you already know the data type of the asset, you can use one of <code>VectorConfig</code>, <code>RasterConfig</code>, <code>PointConfig</code> to declare the config. If you have a linter available, the linter can help pre-validate your input or suggest missing required fields when using the config classes.</p>"},{"location":"introduction/","title":"Introduction","text":""},{"location":"introduction/#terminologies","title":"Terminologies","text":"<p><code>stac_generator</code> generates a STAC collection from information that can be extracted from the spatio-temporal asset and from data provided by users.</p> <p></p> <p>A STAC item is a core component of the STAC specification, designed to describe a single geospatial asset or dataset. The key attributes of a STAC item includes: - <code>id</code>: identifier - <code>datetime</code>: the timestamp when the item is collected - <code>asset</code>: information about the asset, primarily its location <code>href</code>. - <code>geometry</code>: item geometry type and coordinates - <code>bbox</code>: item bounding box</p> Example STAC Item <pre><code>{\n  \"type\": \"Feature\",\n  \"stac_version\": \"1.0.0\",\n  \"stac_extensions\": [\n    \"https://stac-extensions.github.io/projection/v1.1.0/schema.json\",\n    \"https://stac-extensions.github.io/eo/v1.1.0/schema.json\",\n    \"https://stac-extensions.github.io/raster/v1.1.0/schema.json\"\n  ],\n  \"id\": \"L2A_PVI\",\n  \"geometry\": {\n    \"type\": \"Polygon\",\n    \"coordinates\": [\n      [\n        [\n          15.110630736098942,\n          36.95292538275869\n        ],\n        [\n          15.110630736098942,\n          37.947537561322136\n        ],\n        [\n          13.876365195204773,\n          37.947537561322136\n        ],\n        [\n          13.876365195204773,\n          36.95292538275869\n        ],\n        [\n          15.110630736098942,\n          36.95292538275869\n        ]\n      ]\n    ]\n  },\n  \"bbox\": [\n    13.876365195204773,\n    36.95292538275869,\n    15.110630736098942,\n    37.947537561322136\n  ],\n  \"properties\": {\n    \"proj:code\": \"EPSG:32633\",\n    \"proj:shape\": [\n      343,\n      343\n    ],\n    \"proj:transform\": [\n      320.0,\n      0.0,\n      399960.0,\n      0.0,\n      -320.0,\n      4200000.0,\n      0.0,\n      0.0,\n      1.0\n    ],\n    \"eo:bands\": [\n      {\n        \"name\": \"b04\",\n        \"common_name\": \"red\",\n        \"description\": \"Common name: red\",\n        \"center_wavelength\": 0.6645\n      },\n      {\n        \"name\": \"b03\",\n        \"common_name\": \"green\",\n        \"description\": \"Common name: green\",\n        \"center_wavelength\": 0.56\n      },\n      {\n        \"name\": \"b02\",\n        \"common_name\": \"blue\",\n        \"description\": \"Common name: blue\",\n        \"center_wavelength\": 0.4966\n      }\n    ],\n    \"eo:cloud_cover\": 0.0,\n    \"eo:snow_cover\": 0.0,\n    \"datetime\": \"2021-02-21T09:10:17Z\",\n    \"start_datetime\": \"2021-02-21T09:10:17Z\",\n    \"end_datetime\": \"2021-02-21T09:10:17Z\"\n  },\n  \"links\": [\n    {\n      \"rel\": \"root\",\n      \"href\": \"http://example.com/collection.json\",\n      \"type\": \"application/json\",\n      \"title\": \"Auto-generated.\"\n    },\n    {\n      \"rel\": \"collection\",\n      \"href\": \"http://example.com/collection.json\",\n      \"type\": \"application/json\",\n      \"title\": \"Auto-generated.\"\n    },\n    {\n      \"rel\": \"self\",\n      \"href\": \"http://example.com/L2A_PVI/L2A_PVI.json\",\n      \"type\": \"application/json\"\n    },\n    {\n      \"rel\": \"parent\",\n      \"href\": \"http://example.com/collection.json\",\n      \"type\": \"application/json\",\n      \"title\": \"Auto-generated.\"\n    }\n  ],\n  \"assets\": {\n    \"data\": {\n      \"href\": \"tests/files/integration_tests/raster/data/L2A_PVI.tif\",\n      \"type\": \"image/tiff; application=geotiff\",\n      \"title\": \"Raster Data\",\n      \"raster:bands\": [\n        {\n          \"nodata\": 0,\n          \"data_type\": \"uint16\"\n        },\n        {\n          \"nodata\": 0,\n          \"data_type\": \"uint16\"\n        },\n        {\n          \"nodata\": 0,\n          \"data_type\": \"uint16\"\n        }\n      ],\n      \"eo:bands\": [\n        {\n          \"name\": \"b04\",\n          \"common_name\": \"red\",\n          \"description\": \"Common name: red\",\n          \"center_wavelength\": 0.6645\n        },\n        {\n          \"name\": \"b03\",\n          \"common_name\": \"green\",\n          \"description\": \"Common name: green\",\n          \"center_wavelength\": 0.56\n        },\n        {\n          \"name\": \"b02\",\n          \"common_name\": \"blue\",\n          \"description\": \"Common name: blue\",\n          \"center_wavelength\": 0.4966\n        }\n      ],\n      \"roles\": [\n        \"data\"\n      ]\n    }\n  },\n  \"collection\": \"raster_data\"\n}\n</code></pre> <p>Collection is a set of STAC Item. It is used to group related STAC Items that share common properties, metadata, or themes. A collection provides a higher-level metadata description for a dataset or group of assets: - <code>id</code>: collection id - <code>spatial_extent</code>: areal coverage - <code>temporal_extent</code>: temporal coverage - <code>links</code>: associated child items and assets</p> Example Collection JSON <pre><code>{\n  \"type\": \"Collection\",\n  \"id\": \"raster_data\",\n  \"stac_version\": \"1.0.0\",\n  \"description\": \"Auto-generated\",\n  \"links\": [\n    {\n      \"rel\": \"root\",\n      \"href\": \"http://example.com/collection.json\",\n      \"type\": \"application/json\",\n      \"title\": \"Auto-generated.\"\n    },\n    {\n      \"rel\": \"item\",\n      \"href\": \"http://example.com/L2A_PVI/L2A_PVI.json\",\n      \"type\": \"application/json\"\n    },\n    {\n      \"rel\": \"self\",\n      \"href\": \"http://example.com/collection.json\",\n      \"type\": \"application/json\"\n    }\n  ],\n  \"title\": \"Auto-generated.\",\n  \"extent\": {\n    \"spatial\": {\n      \"bbox\": [\n        [\n          13.876365195204773,\n          36.95292538275869,\n          15.110630736098942,\n          37.947537561322136\n        ]\n      ]\n    },\n    \"temporal\": {\n      \"interval\": [\n        [\n          \"2021-02-21T09:10:17Z\",\n          \"2021-02-21T09:10:17Z\"\n        ]\n      ]\n    }\n  },\n  \"license\": \"proprietary\"\n}\n\n</code></pre> <p>To run the <code>stac_generator</code>, a config file must be provided. In essence, the config file contains the asset locations and additional user-supplied metadata, from which the STAC Item is generated. Refer to quick start to see how to build a simple config, or refer to the specication to see what fields are supported in the config.</p>"},{"location":"introduction/#data-types","title":"Data Types","text":"<p><code>stac_generator</code> classifies assets into <code>raster</code>, <code>vector</code>, and <code>point</code> data, using terminologies consistent with common GIS softwares. In general:</p> <ul> <li>Point data contains one or more entries where each entry has the <code>X</code> and <code>Y</code> fields describing the location. Each entry usually contains other fields describing the attributes at the point location. For instance, this can be soil sample measurements or raw instrument readings at a particular coordinate. Point data can also have a field representing depth/elevation or time.</li> <li>Vector data contains a collection of points whose relationship is determined by the vector type - (point, multipoint, line, multiline, polygon, multipolygon, etc). Vector data are usually shape files describing a plot or a field boundary, but can also contain plot level attributes - i.e. mean elevation, mean temperature, cumulative rainfall, etc.</li> <li>Raster data contains several 2D layers (called bands) where each band represents the attribute value at each (x, y) coordinate in the 2D grid. For instance, an orthomosaic contains RGB bands, where each band is a 2D matrix with value between 0 and 255.</li> </ul>"},{"location":"introduction/#supported-formats-for-data-assets","title":"Supported Formats for data assets","text":"<ul> <li>Raster:<ul> <li>tif</li> <li>geotif</li> </ul> </li> <li>Vector:<ul> <li>shp</li> <li>geojson</li> <li>zip+shp</li> <li>geopkg</li> </ul> </li> <li>Point:<ul> <li>csv</li> <li>txt</li> </ul> </li> </ul> <p>Note that in some cases, plot or field level attributes are recorded in a csv that does not contain X and Y columns but a plot or field ID column referencing the same attribute in a separate vector file. This additional information can be provided using the <code>join_</code> keywords in the vector config. Please see the documentation for more information.</p>"},{"location":"introduction/#collection-metadata","title":"Collection metadata","text":"<p>Aside from <code>datetime</code>, <code>start_datetime</code>, <code>end_datetime</code>, collection metadata contains fields described in STAC Common Metadata. In general, the most important fields are <code>id</code> (required), <code>keywords</code> (optional - can be useful for catalog filtering feature in the future), <code>license</code> (optional - licensing information).</p> <p>For a more detailed list of all fields, their data types, and default values, please refer to <code>STACCollectionConfig</code> under this link.</p>"},{"location":"introduction/#item-metadata","title":"Item metadata","text":"<p>Item metadata contains all fields in collection metadata and additional required <code>collection_date</code> and <code>collection_time</code> fields describing when the item was collected. Item metadata must also specify the <code>location</code> field, that points to where the data asset is stored.</p> <p>For a more detailed list of all fields, their data types, and default values, please refer to <code>STACItemConfig</code> and <code>SourceConfig</code> under this link.</p>"},{"location":"introduction/#point-metadata","title":"Point metadata","text":"<p>Point metadata contains all fields in item metadata (inherits from <code>SourceConfig</code>) and contains additional fields specifying how to process the given csv/txt file. This includes the <code>X</code> and <code>Y</code> fields specifying the columns to be treated as the X and Y coordinates, the <code>epsg</code> code specifying the CRS of the XY coordinates, and if the csv contains columns to be treated as depth/elevation or time, the optional <code>Z</code>, <code>T</code> and <code>time_format</code> fields.</p> <p>Users should also specify useful columns under <code>column_info</code> (please see <code>ColumnInfo</code> and <code>HasColumnInfo</code> under this link). For a more detailed list of all fields, their data types, and default values, please refer to <code>PointConfig</code> under this link.</p>"},{"location":"introduction/#vector-metadata","title":"Vector metadata","text":"<p>Vector metadata contains all fields in item metadata (inherits from <code>SourceConfig</code>). Since vector data is often self-described, vector metadata only requires the <code>epsg</code> code for sanity checking - i.e. to ensure that users know whether they are providing the right asset. If the vector data is a compressed zip file with multiple shp files, a <code>layer</code> field is needed to specify which <code>shp</code> file in the zip package the metadata is describing. If the vector data contains plot or field level attributes, the <code>column_info</code> should also be used.</p> <p>Users should also specify useful columns under <code>column_info</code> (please see <code>ColumnInfo</code> and <code>HasColumnInfo</code> under this link). For a more detailed list of all fields, their data types, and default values, please refer to <code>VectorConfig</code> under this link.</p> <p>A common practice in spatial application involves storing geometry information in one table and attributes in another, and a join operation is performed at run time to generate the combined data. To simplify the workflow, we assume the geometry information is stored in a vector file and the attributes stored in a csv. We can specify <code>join_file</code> to be the path to the attribute csv file. <code>join_field</code> to be a column in <code>join_file</code> and <code>join_attribute_vector</code> to be an attribute in the vector file. The two files will be joined at each record where <code>join_file</code> = <code>join_attribute_vector</code>. <code>join_column_info</code> must also be provided to describe the columns in the <code>join_file</code>.</p>"},{"location":"introduction/#raster-metadata","title":"Raster metadata","text":"<p>Raster metadata contains all fields in item metadata (inherits from <code>SourceConfig</code>). <code>band_info</code> is the only required field in a raster config.</p> <p>For a more detailed list of all fields, their data types, and default values, please refer to <code>RasterConfig</code> under this link.</p>"},{"location":"quick_start/","title":"Quickstart","text":""},{"location":"quick_start/#vector-data","title":"Vector Data","text":"<p>In the following tutorial, we will use the <code>stac_generator</code> to describe a vector file. For starters, please download this file, which contains boundaries for some suburbs in Werribee Melbourne.</p> <p>If you have QGIS, you can visualise the layer:</p> <p></p> <p>Create a folder called <code>Example</code>, move the downloaded file to <code>Example</code>, then open a terminal in <code>Example</code>.</p>"},{"location":"quick_start/#describing-a-vector-file","title":"Describing a vector file","text":"<p>Before using the stac generator, we will write a config file to be passed to the <code>stac_generator</code>. A config file is a csv or json file that describes a set of STAC items in a collection. At the bare minimum, it must contain the path to the asset, the STAC Item unique identifier (id), and the date and time when the asset was collected. Our first, very simple config will look like this:</p> JSON <pre><code>[\n    {\n        \"id\": \"Werribee\",\n        \"location\": \"Werribee.geojson\",\n        \"collection_date\": \"2025-01-01\",\n        \"collection_time\": \"00:00:00\"\n    }\n]\n</code></pre> CSV <pre><code>id,location,collection_date,collection_time\nWerribee,Werribee.geojson,2025-01-01,00:00:00\n</code></pre> <p>In this example, the item's id is <code>Werribee</code>. The asset location is <code>Werribee.geojson</code>, which means <code>Werribee.geojson</code> should be discovered in the current directory <code>Example</code>. We have also provided the <code>collection_date</code> and <code>collection_time</code> in the config. Save the config file (either the csv or json) in the current directory - i.e <code>vector_simple_config.json</code> or <code>vector_simple_config.csv</code>. If you use the csv version, change the name accordingly in the example commands.</p> <p>Now run the stac generator serialise command from the terminal:</p> <pre><code>stac_generator serialise vector_simple_config.json --id Werribee_Collection --dst generated\n</code></pre> <p>The first positional argument is the path to the config file. The first keyword argument <code>id</code> (required) is the id of the generated collection. The second keyword argument <code>dst</code> is the location the generated records should be saved.</p> <p>Once this command is run, we should see a <code>generated</code> folder in the current directory. Upon opening <code>generated</code>, you will see a <code>collection.json</code> which is the STAC Collection metadata, and a <code>Werribee</code> folder containing <code>Werribee.json</code>, which is the STAC item metadata.</p> <p>You can now verify that the <code>id</code> provided in the command line (<code>Werribee_Collection</code>) corresponds to the <code>id</code> in <code>collection.json</code>, the <code>id</code> in <code>Werribee.json</code> corresponds to the <code>id</code> provided in <code>vector_simple_config.json</code>, and the asset's href in <code>Werribee.json</code> corresponds to the <code>location</code> provided in <code>vector_simple_config.json</code>.</p>"},{"location":"quick_start/#describing-vector-attributes","title":"Describing vector attributes","text":"<p>So far, we have learned to write a bare-minimum config to describe a vector asset and use the stac generator command to generate the metadata record. In this example, we will learn how to add additional metadata to better describe the asset. For instance, we may now want to add a <code>title</code> and a <code>description</code> to our STAC record and also to describe some attributes contained in the vector file. We can see that <code>Werribee.geojson</code> has an attribute called <code>Suburb_Name</code>:</p> <p></p> JSON <pre><code>[\n    {\n        \"id\": \"Werribee\",\n        \"location\": \"Werribee.geojson\",\n        \"collection_date\": \"2025-01-01\",\n        \"collection_time\": \"00:00:00\",\n        \"title\": \"Werribee Item\",\n        \"description\": \"Suburbs near Werribee Melbourne\",\n        \"column_info\": [{\"name\": \"Suburb_Name\", \"description\": \"suburb name\"}]\n    }\n]\n</code></pre> <p>Save this config as <code>vector_detailed_config.json</code> in the same folder. Now run the command:</p> <pre><code>stac_generator serialise vector_detailed_config.json --id Werribee_Collection --dst generated\n</code></pre> <p>Upon checking the generated STAC Item <code>Werribee.json</code>, we now see <code>column_info</code>, <code>title</code>, and <code>description</code> fields appearing under <code>properties</code>.</p>"},{"location":"quick_start/#describing-joined-attributes","title":"Describing joined attributes","text":"<p>A common practice in spatial application involves storing geometry information in one table and attributes in another, and a join operation is performed at run time to generate the combined data. To simplify the workflow, we assume the geometry information is stored in a vector file and the attributes stored in a csv. The stac generator can describe the join operation with a few extra keywords in the config. Before running the stac generator, download the join file and put it in the current directory <code>Example</code>. Our config now looks like this:</p> <pre><code>[\n    {\n        \"id\": \"Werribee\",\n        \"location\": \"Werribee.geojson\",\n        \"collection_date\": \"2025-01-01\",\n        \"collection_time\": \"00:00:00\",\n        \"column_info\": [\n            {\n                \"name\": \"Suburb_Name\",\n                \"description\": \"Suburb_Name\"\n            }\n        ],\n        \"join_file\": \"distance.csv\",\n        \"join_field\": \"Area\",\n        \"join_attribute_vector\": \"Suburb_Name\",\n        \"join_column_info\": [\n            {\n                \"name\": \"Distance\",\n                \"description\": \"Driving Distance to CBD in km\"\n            },\n            {\n                \"name\": \"Public_Transport\",\n                \"description\": \"Time taken to reach CBD by public transport in minutes\"\n            },\n            {\n                \"name\": \"Drive\",\n                \"description\": \"Time taken to reach CBD by driving in minutes\"\n            },\n            {\n                \"name\": \"Growth\",\n                \"description\": \"Average 5 year growth in percentage in 2025\"\n            },\n            {\n                \"name\": \"Yield\",\n                \"description\": \"Average rental yield in 2025\"\n            }\n        ]\n    }\n]\n</code></pre> <p>We specified <code>join_file</code> to be the path to the attribute csv file. <code>join_field</code> to be a column in <code>join_file</code> and <code>join_attribute_vector</code> to be an attribute in the vector file. The two files will be joined at each record where <code>join_file</code> = <code>join_attribute_vector</code>. <code>join_column_info</code> describes the columns in the <code>join_file</code>. Save the new config as <code>vector_join_config.json</code> and run the stac generator command:</p> <pre><code>stac_generator serialise vector_join_config.json --id Werribee_Collection --dst generated\n</code></pre> <p>You should see the corresponding fields appearing under <code>properties</code> in <code>Werribee.json</code>.</p>"},{"location":"quick_start/#describing-multi-layerd-shape-file","title":"Describing multi-layerd shape file","text":"<p>It is not uncommon to have a compressed zip containing multiple shape files. Such a zip file can be handled directly. To get started, download this file which contains some SA2 areas in Victoria:</p> <p></p> <p>Here we have two layers - Sunbury and Werribee. Each layer will be generated as a STAC item, and we will need to describe each layer independently as a record in the config. We may choose to describe all or a subset of the layers.</p> JSON <pre><code>[\n    {\n        \"id\": \"WerribeeSA2\",\n        \"location\": \"SA2.zip\",\n        \"collection_date\": \"2025-01-01\",\n        \"collection_time\": \"00:00:00\",\n        \"layer\": \"Werribee\"\n    },\n    {\n        \"id\": \"SunburySA2\",\n        \"location\": \"SA2.zip\",\n        \"collection_date\": \"2025-01-01\",\n        \"collection_time\": \"00:00:00\",\n        \"layer\": \"Sunbury\"\n    }\n]\n</code></pre> <p>Save the new config as <code>vector_layer_config.json</code> and run the command:</p> <pre><code>stac_generator serialise vector_layer_config.json --id SA2_Collection --dst generated\n</code></pre> <p>You will see two items generated, <code>WerribeSA2</code> and <code>SunburySA2</code>. Note that each config record has a <code>layer</code> keyword to identify the layer in the compressed zip. We use a simple config to describe each layer, but it is possible to add additional information like column info and join attributes as described in the previous sections.</p>"},{"location":"quick_start/#describing-multiple-vector-files","title":"Describing multiple vector files","text":"<p>To describe another independent vector file, you can add another record in the config file. For instance, we want to describe both the <code>SA2.zip</code> and the <code>Werribee.geojson</code> files:</p> JSON <pre><code>[\n    {\n        \"id\": \"WerribeeSA2\",\n        \"location\": \"SA2.zip\",\n        \"collection_date\": \"2025-01-01\",\n        \"collection_time\": \"00:00:00\",\n        \"layer\": \"Werribee\"\n    },\n    {\n        \"id\": \"SunburySA2\",\n        \"location\": \"SA2.zip\",\n        \"collection_date\": \"2025-01-01\",\n        \"collection_time\": \"00:00:00\",\n        \"layer\": \"Sunbury\"\n    },\n        {\n        \"id\": \"Werribee\",\n        \"location\": \"Werribee.geojson\",\n        \"collection_date\": \"2025-01-01\",\n        \"collection_time\": \"00:00:00\",\n        \"column_info\": [\n            {\n                \"name\": \"Suburb_Name\",\n                \"description\": \"Suburb_Name\"\n            }\n        ],\n        \"join_file\": \"distance.csv\",\n        \"join_field\": \"Area\",\n        \"join_attribute_vector\": \"Suburb_Name\",\n        \"join_column_info\": [\n            {\n                \"name\": \"Distance\",\n                \"description\": \"Driving Distance to CBD in km\"\n            },\n            {\n                \"name\": \"Public_Transport\",\n                \"description\": \"Time taken to reach CBD by public transport in minutes\"\n            },\n            {\n                \"name\": \"Drive\",\n                \"description\": \"Time taken to reach CBD by driving in minutes\"\n            },\n            {\n                \"name\": \"Growth\",\n                \"description\": \"Average 5 year growth in percentage in 2025\"\n            },\n            {\n                \"name\": \"Yield\",\n                \"description\": \"Average rental yield in 2025\"\n            }\n        ]\n    }\n]\n</code></pre> <p>Despite its size, this is a simple concatenation of the records in the previous two sections. This will generate a <code>WerribeeSA2</code> item and a <code>SunburySA2</code> item from the <code>SA2.zip</code> file, and a <code>Werribee</code> item with join attribute from <code>distance.csv</code>. Save the new config as <code>vector_combined_config.json</code> and run the stac generator:</p> <pre><code>stac_generator serialise vector_combined_config.json --id Vector_Collection --dst generated\n</code></pre>"},{"location":"quick_start/#raster-data","title":"Raster Data","text":"<p>For raster assets, users are required to declare recorded bands under <code>band_info</code> field. In the next examples, we will describe a tif with common sensor bands, and a tif with custom bands.</p>"},{"location":"quick_start/#describing-common-bands","title":"Describing common bands","text":"<p>The asset (please download the asset an put in the <code>Example</code> folder) in this example is an RGB tif file (shown below):</p> <p></p> <p>We will prepare the following <code>raster_simple_config.json</code>:</p> JSON <pre><code>[\n  {\n    \"id\": \"L2A_PVI\",\n    \"location\": \"L2A_PVI.tif\",\n    \"collection_date\": \"2021-02-21\",\n    \"collection_time\": \"10:00:17\",\n    \"band_info\": [\n      {\n        \"name\": \"B04\",\n        \"common_name\": \"red\",\n        \"description\": \"Common name: red, Range: 0.6 to 0.7\",\n        \"wavelength\": 0.6645\n      },\n      {\n        \"name\": \"B03\",\n        \"common_name\": \"green\",\n        \"description\": \"Common name: green, Range: 0.5 to 0.6\",\n        \"wavelength\": 0.56\n      },\n      {\n        \"name\": \"B02\",\n        \"common_name\": \"blue\",\n        \"description\": \"Common name: blue, Range: 0.45 to 0.5\",\n        \"wavelength\": 0.4966\n      }\n    ]\n  }\n]\n</code></pre> <p>Please note how the RGB bands are described under <code>band_info</code>. The wavelengths are read from device specifications. To serialise the metadata:</p> <pre><code>stac_generator serialise raster_simple_config.json --id simple_raster --dst generated\n</code></pre>"},{"location":"quick_start/#describing-uncommonunknown-bands","title":"Describing uncommon/unknown bands","text":"<p>The asset(please download the asset an put in the <code>Example</code> folder) in this example is a greyscale tif file (shown below):</p> <p></p> <p>We will prepare the following <code>raster_custom_config.json</code>:</p> JSON <pre><code>[\n  {\n    \"id\": \"vegetation_cover\",\n    \"location\": \"vegetation_cover.tif\",\n    \"collection_date\": \"2021-02-21\",\n    \"collection_time\": \"10:00:17\",\n    \"band_info\": [\n      {\n        \"name\": \"vegetation\",\n        \"description\": \"Vegetation cover level\"\n      }\n    ]\n  }\n]\n</code></pre> <p>The band info is a lot simpler than the previous example given that the band is not raw sensor readings (no wavelength). To serialise the metadata:</p> <pre><code>stac_generator serialise raster_custom_config.json --id custom_raster --dst generated\n</code></pre>"},{"location":"quick_start/#point-data","title":"Point Data","text":"<p>The <code>stac_generator</code> uses the <code>csv</code> format to store point data. Given the flexibility of the csv format, we require point dataset to be structured in a particular way. Each row of the csv file describes a point, with columns being the attributes. At the minimum, there must be two columns describing the coordinates of the points. The required config fields include:</p> <ul> <li><code>X</code>: the column in the csv asset to describe the longitude.</li> <li><code>Y</code>: the column in the csv asset to describe the latitude.</li> <li><code>epsg</code>: the crs of the <code>X</code>, <code>Y</code> columns.</li> </ul> <p>There can also be optional columns:</p> <ul> <li><code>T</code>: the column in the csv asset that describes the date of collection of a point record.</li> <li><code>date_format</code>: how the date string is interpreted - by default, dates are assumed to be <code>ISO8640</code> compliant.</li> <li><code>Z</code>: the column in the csv asset that describes the altitude.</li> <li><code>column_info</code>: describe the relevant names and descriptions of relavant attributes.</li> </ul>"},{"location":"quick_start/#describing-time-series-data","title":"Describing time series data","text":"<p>The asset(please download the asset an put in the <code>Example</code> folder) in this example is a time series dataset with a date column (<code>YYYY-MM-DD</code>) (shown below):</p> longitude latitude elevation station YYYY-MM-DD daily_rain max_temp 138.519 -34.952 2 23304 2020-01-01 0 32.2 <p>We prepare the <code>point_time_series_config.json</code> as follows:</p> JSON <pre><code>[\n  {\n    \"id\": \"BOM_Data\",\n    \"location\": \"bom.csv\",\n    \"collection_date\": \"2020-01-01\",\n    \"collection_time\": \"10:00:00\",\n    \"X\": \"longitude\",\n    \"Y\": \"latitude\",\n    \"Z\": \"elevation\",\n    \"T\": \"YYYY-MM-DD\",\n    \"epsg\": 4326,\n    \"column_info\": [\n      {\n        \"name\": \"daily_rain\",\n        \"description\": \"daily rain fall in mm\"\n      },\n      {\n        \"name\": \"max_temp\",\n        \"description\": \"daily maximum temperature in C\"\n      }\n    ]\n  }\n]\n</code></pre> <p>The values for <code>X</code>, <code>Y</code>, <code>Z</code>, <code>T</code> are obtained from the raw csv - i.e. longitude, latitude, elevation and YYYY-MM-DD respectively.</p> <p><code>epsg</code> value cannot be derived from the csv and must be known by the user - i.e. reading dataset metadata on BOM/SILO website.</p> <p>The field <code>column_info</code> contains useful columns that the user want to describe.</p> <p>To serialise the metadata:</p> <pre><code>stac_generator serialise point_time_series_config.json --id time_series --dst generated\n</code></pre>"},{"location":"quick_start/#describing-generic-point-data","title":"Describing generic point data","text":"<p>The asset(please download the asset an put in the <code>Example</code> folder) in this example is a generic point dataset with no date column (shown below):</p> property field profile easting northing Ca_Soln Sunbury Jordie 3 773215.36 678187.36 3 <p>The config - <code>point_simple_config.json</code> is described below:</p> JSON <pre><code>[\n  {\n    \"id\": \"soil_data\",\n    \"location\": \"soil.csv\",\n    \"collection_date\": \"2020-01-01\",\n    \"collection_time\": \"10:00:00\",\n    \"X\": \"eastings_utm\",\n    \"Y\": \"northings_utm\",\n    \"epsg\": 28355,\n    \"column_info\": [\n      {\n        \"name\": \"ca_soln\",\n        \"description\": \"Calcium solution in ppm\"\n      },\n      {\n        \"name\": \"profile\",\n        \"description\": \"Field profile\"\n      }\n    ]\n  }\n]\n\n</code></pre> <p>The values for <code>X</code>, <code>Y</code> are obtained from the raw csv - i.e. easting and northing respectively.</p> <p>There is no elevation and time column so they can be left blank.</p> <p>The value for <code>epsg</code> must be known before hand, in this example, we assume it to be GDA94/MGA55 with espg code 28355. Also assuming values for property and field are not important in this example, we don\u2019t include them in <code>column_info</code>.</p> <p>To serialise the metadata:</p> <pre><code>stac_generator serialise point_simple_config.json --id soil --dst generated\n</code></pre>"},{"location":"quick_start/#composite-data","title":"Composite Data","text":"<p>It is not uncommon to have more than one data types in a project. To describe multiple items of different data types, we can use a combined config or we can pass all the configs to the CLI at once.</p>"},{"location":"quick_start/#using-a-combined-config","title":"Using a combined config","text":"<p>Let's say you want to describe items in <code>raster_simple_config.json</code>, <code>point_simple_config.json</code>, and <code>vector_simple_config.json</code>, an easy way is to make a <code>combined_config.json</code> with entries from all the sub configs:</p> JSON <pre><code>[\n    {\n        \"id\": \"Werribee\",\n        \"location\": \"Werribee.geojson\",\n        \"collection_date\": \"2025-01-01\",\n        \"collection_time\": \"00:00:00\"\n    },\n    {\n        \"id\": \"soil_data\",\n        \"location\": \"soil.csv\",\n        \"collection_date\": \"2020-01-01\",\n        \"collection_time\": \"10:00:00\",\n        \"X\": \"eastings_utm\",\n        \"Y\": \"northings_utm\",\n        \"epsg\": 28355,\n        \"column_info\": [\n            {\n                \"name\": \"ca_soln\",\n                \"description\": \"Calcium solution in ppm\"\n            },\n            {\n                \"name\": \"profile\",\n                \"description\": \"Field profile\"\n            }\n        ]\n    },\n    {\n        \"id\": \"L2A_PVI\",\n        \"location\": \"L2A_PVI.tif\",\n        \"collection_date\": \"2021-02-21\",\n        \"collection_time\": \"10:00:17\",\n        \"band_info\": [\n            {\n                \"name\": \"B04\",\n                \"common_name\": \"red\",\n                \"description\": \"Common name: red, Range: 0.6 to 0.7\",\n                \"wavelength\": 0.6645\n            },\n            {\n                \"name\": \"B03\",\n                \"common_name\": \"green\",\n                \"description\": \"Common name: green, Range: 0.5 to 0.6\",\n                \"wavelength\": 0.56\n            },\n            {\n                \"name\": \"B02\",\n                \"common_name\": \"blue\",\n                \"description\": \"Common name: blue, Range: 0.45 to 0.5\",\n                \"wavelength\": 0.4966\n            }\n        ]\n    }\n]\n</code></pre> <p>To serialise this collection, run:</p> <pre><code>stac_generator serialise combined_config.json --id combined --dst generated\n</code></pre>"},{"location":"quick_start/#using-multiple-configs","title":"Using multiple configs","text":"<p>We can pass multiple config files to the CLI. For instance, to describe all simple configs similar to the previous example, we can run:</p> <pre><code>stac_generator serialise point_simple_config.json raster_simple_config.json vector_simple_config.json --id combined --dst generated\n</code></pre>"},{"location":"quick_start/#advanced-using-stac_generator-as-a-python-module","title":"Advanced - Using <code>stac_generator</code> as a python module","text":"<p>So far, we have seen how <code>stac_generator</code> can be used as a command line tool to generate STAC metadata. In this section, we will see how to use <code>stac_generator</code> as a module. This means we can now write python scripts that import the <code>stac_generator</code> module and perform the previous tasks:</p> PYTHON"},{"location":"quick_start/#help","title":"Help","text":"<p>To view the supported parameters and keywords for the <code>serialise</code> command, run</p> <pre><code>stac_generator serialise --help\n</code></pre> <p>To view all supported commands, run</p> <pre><code>stac_generator --help\n</code></pre> <p>Note that  <code>STAC common metadata</code> fields can be ignored for now.</p>"},{"location":"quick_start/#a-note-on-location-field","title":"A note on <code>location</code> field","text":"<p>Throughout this tutorial, we use relative paths for our asset's location. In practice, we recommend using an absolute path to local asset (if you want to the data to be discovered only locally) or a URL to the hosted asset (if you want to share the metadata and asset with someone else).</p>"},{"location":"quick_start/#a-note-on-using-csv-format-as-configs","title":"A note on using <code>csv</code> format as configs","text":"<p>We recommend using <code>json</code> for configs, as <code>csv</code> is not the most convenient format to represent nested fields like <code>column_info</code> or <code>band_info</code>. The only supported method to represent nested fields in <code>csv</code> is to represent them as <code>json</code> encoded string. For instance, the following configs are equivalent:</p> JSON <pre><code>[\n  {\n    \"location\": \"data.geojson\",\n    \"column_info\": [\n      {\"name\": \"ID\", \"description\": \"Item ID\"},\n      {\"name\": \"Age\", \"description\": \"Age\"}\n    ]\n  }\n]\n</code></pre> <p>We will prepare the csv as follows:</p> CSV <pre><code>location, column_info\ndata.geojson,\"[{\"\"name\"\": \"\"ID\"\", \"\"description\"\": \"\"Item ID\"\"}, {\"\"name\"\": \"\"Age\"\", \"\"description\"\": \"\"Age\"\"}]\"\n</code></pre> <p>Note how we use <code>\"\"</code> to represent an item in the csv format. Describing multiple items using a <code>csv</code> config can be done by representing each item as a row in the csv config. For describing multiple items of different data type, we recommend using the multiple config approach, preparing several configs of the same data type then passing them to the CLI. For instance:</p> <pre><code>stac_generator serialise vector.csv raster.csv point.csv --id collection --dst generated\n</code></pre>"},{"location":"schema/","title":"Schema","text":""},{"location":"schema/#core.base.schema.StacCollectionConfig","title":"<code>StacCollectionConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains parameters to pass to Collection constructor. Also contains other metadata except for datetime related metadata.</p> <p>Collection's datetime, start_datetime and end_datetime will be derived from the time information of its children items</p> <p>This config provides additional information that can not be derived from source file, which includes Stac Common Metadata and other descriptive information such as the id of the new entity</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>Item id</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.title","title":"<code>title = 'Auto-generated Stac Item'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A human readable title describing the item entity. https://github.com/radiantearth/stac-spec/blob/master/commons/common-metadata.md#basics</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.description","title":"<code>description = 'Auto-generated Stac Item'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Detailed multi-line description to fully explain the STAC entity. https://github.com/radiantearth/stac-spec/blob/master/commons/common-metadata.md#basics</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.license","title":"<code>license = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>License(s) of the data as SPDX License identifier, SPDX License expression, or other - https://github.com/radiantearth/stac-spec/blob/master/commons/common-metadata.md#licensing</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.providers","title":"<code>providers = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of providers, which may include all organizations capturing or processing the data or the hosting provider. Providers should be listed in chronological order with the most recent provider being the last element of the list. - https://github.com/radiantearth/stac-spec/blob/master/commons/common-metadata.md#provider</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.platform","title":"<code>platform = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique name of the specific platform to which the instrument is attached. https://github.com/radiantearth/stac-spec/blob/master/commons/common-metadata.md#platform</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.instruments","title":"<code>instruments = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of instrument or sensor used (e.g., MODIS, ASTER, OLI, Canon F-1). https://github.com/radiantearth/stac-spec/blob/master/commons/common-metadata.md#instrument</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.constellation","title":"<code>constellation = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the constellation to which the platform belongs. https://github.com/radiantearth/stac-spec/blob/master/commons/common-metadata.md#constellation</p>"},{"location":"schema/#core.base.schema.StacCollectionConfig.mission","title":"<code>mission = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the mission for which data is collected. https://github.com/radiantearth/stac-spec/blob/master/commons/common-metadata.md#mission</p>"},{"location":"schema/#core.base.schema.StacItemConfig","title":"<code>StacItemConfig</code>","text":"<p>               Bases: <code>StacCollectionConfig</code></p> <p>Contains parameters to pass to Item constructor. Also contains other metadata except for datetime related metadata.</p> <p>Item's datetime will be superseded by <code>collection_date</code> and <code>collection_time</code> recorded in local timezone. The STAC <code>datetime</code> metadata is obtained from the method <code>get_datetime</code> by providing the local timezone, which will be automatically derived from the crs information.</p> <p>This config provides additional information that can not be derived from source file, which includes Stac Common Metadata and other descriptive information such as the id of the new entity</p>"},{"location":"schema/#core.base.schema.StacItemConfig.collection_date","title":"<code>collection_date</code>  <code>instance-attribute</code>","text":"<p>Date in local timezone of when the data is collected</p>"},{"location":"schema/#core.base.schema.StacItemConfig.collection_time","title":"<code>collection_time</code>  <code>instance-attribute</code>","text":"<p>Time in local timezone of when the data is collected</p>"},{"location":"schema/#core.base.schema.SourceConfig","title":"<code>SourceConfig</code>","text":"<p>               Bases: <code>StacItemConfig</code></p> <p>Base source config that should be subclassed for different file extensions.</p> <p>Source files contain raw spatial information (i.e. geotiff, shp, csv) from which some Stac metadata can be derived. SourceConfig describes:</p> <ul> <li>The access mechanisms for the source file: stored on local disk, or hosted somewhere behind an api endpoint. If the source file must be accessed through an endpoint, users can provide additional HTTP information that forms the HTTP request to the host server.</li> <li>Processing information that are unique for the source type. Users should inherit <code>SourceConfig</code> for file extensions currently unsupported.</li> <li>Additional Stac Metadata from <code>StacConfig</code></li> </ul>"},{"location":"schema/#core.base.schema.SourceConfig.location","title":"<code>location</code>  <code>instance-attribute</code>","text":"<p>Asset's href</p>"},{"location":"schema/#core.base.schema.SourceConfig.extension","title":"<code>extension = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Explicit file extension specification. If the file is stored behind an api endpoint, the field <code>extension</code> must be provided</p>"},{"location":"schema/#core.base.schema.SourceConfig.method","title":"<code>method = 'GET'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTPMethod to acquire the file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.params","title":"<code>params = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query params for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.headers","title":"<code>headers = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query headers for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.cookies","title":"<code>cookies = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query cookies for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.content","title":"<code>content = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.SourceConfig.json_body","title":"<code>json_body = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTTP query body content for getting file from <code>location</code></p>"},{"location":"schema/#core.base.schema.ColumnInfo","title":"<code>ColumnInfo</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict description of GeoDataFrame columns. Used for describing vector/point attributes</p>"},{"location":"schema/#core.base.schema.ColumnInfo.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Column name</p>"},{"location":"schema/#core.base.schema.ColumnInfo.description","title":"<code>description</code>  <code>instance-attribute</code>","text":"<p>Column description</p>"},{"location":"schema/#core.base.schema.ColumnInfo.dtype","title":"<code>dtype</code>  <code>instance-attribute</code>","text":"<p>Column data type</p>"},{"location":"schema/#core.base.schema.HasColumnInfo","title":"<code>HasColumnInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"schema/#core.base.schema.HasColumnInfo.column_info","title":"<code>column_info = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of attributes associated with point/vector data</p>"},{"location":"schema/#core.base.schema.HasColumnInfo.coerce_to_object","title":"<code>coerce_to_object(v)</code>  <code>classmethod</code>","text":"<p>Convert json serialised string of column info into matched object</p>"},{"location":"utils/","title":"Utility","text":""},{"location":"utils/#core.base.utils.parse_href","title":"<code>parse_href(base_url, collection_id, item_id=None)</code>","text":"<p>Generate href for collection or item based on id</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>path to catalog.</p> required <code>collection_id</code> <code>str</code> <p>collection id</p> required <code>item_id</code> <code>str | None</code> <p>item id, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>uri to collection or item</p>"},{"location":"utils/#core.base.utils.href_is_stac_api_endpoint","title":"<code>href_is_stac_api_endpoint(href)</code>","text":"<p>Check if href points to a resource behind a stac api</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>path to resource</p> required <p>Returns:</p> Type Description <code>bool</code> <p>local or non-local</p>"},{"location":"utils/#core.base.utils.force_write_to_stac_api","title":"<code>force_write_to_stac_api(url, id, json)</code>","text":"<p>Force write a json object to a stac api endpoint. This function will try sending a POST request and if a 409 error is encountered, try sending a PUT request. Other exceptions if occured will be raised</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>path to stac resource for creation/update</p> required <code>json</code> <code>dict[str, Any]</code> <p>json object</p> required"},{"location":"utils/#core.base.utils.calculate_timezone","title":"<code>calculate_timezone(geometry)</code>","text":"<p>Calculate timezone from geometry</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Geometry</code> <p>geometry object in EPSG:4326 crs</p> required <p>Returns:</p> Type Description <code>str</code> <p>timezone string</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>very exceptional cases where tzfinder cannot determine timezone</p>"},{"location":"extensions/point/generator/","title":"Generator","text":""},{"location":"extensions/point/generator/#core.point.generator.PointGenerator","title":"<code>PointGenerator</code>","text":"<p>               Bases: <code>VectorGenerator[PointConfig]</code></p> <p>ItemGenerator class that handles point data in csv format</p>"},{"location":"extensions/point/generator/#core.point.generator.PointGenerator.create_item_from_config","title":"<code>create_item_from_config(source_config)</code>","text":"<p>Create item from source csv config</p> <p>Parameters:</p> Name Type Description Default <code>source_config</code> <code>PointConfig</code> <p>config which contains csv metadata</p> required <p>Returns:</p> Type Description <code>pystac.Item</code> <p>stac metadata of the item described in source_config</p>"},{"location":"extensions/point/generator/#core.point.generator.read_csv","title":"<code>read_csv(src_path, X_coord, Y_coord, epsg, Z_coord=None, T_coord=None, date_format='ISO8601', columns=None)</code>","text":"<p>Read in csv from local disk</p> <p>Users must provide at the bare minimum the location of the csv, and the names of the columns to be treated as the X and Y coordinates. By default, will read in all columns in the csv. If columns and groupby columns are provided, will selectively read specified columns together with the coordinate columns (X, Y, T).</p> <p>Parameters:</p> Name Type Description Default <code>src_path</code> <code>str</code> <p>path to csv file</p> required <code>X_coord</code> <code>str</code> <p>name of X field</p> required <code>Y_coord</code> <code>str</code> <p>name of Y field</p> required <code>epsg</code> <code>int</code> <p>epsg code</p> required <code>Z_coord</code> <code>str | None</code> <p>name of Z field</p> <code>None</code> <code>T_coord</code> <code>str | None</code> <p>name of time field, defaults to None</p> <code>None</code> <code>date_format</code> <code>str</code> <p>format to pass to pandas to parse datetime, defaults to \"ISO8601\"</p> <code>'ISO8601'</code> <code>columns</code> <code>list[str] | list[ColumnInfo] | None</code> <p>band information, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>read dataframe</p>"},{"location":"extensions/point/schema/","title":"Schema","text":""},{"location":"extensions/point/schema/#core.point.schema.PointConfig","title":"<code>PointConfig</code>","text":"<p>               Bases: <code>SourceConfig</code>, <code>HasColumnInfo</code></p> <p>Source config for point(csv) data</p>"},{"location":"extensions/point/schema/#core.point.schema.PointConfig.X","title":"<code>X</code>  <code>instance-attribute</code>","text":"<p>Column to be treated as longitude/X coordinate</p>"},{"location":"extensions/point/schema/#core.point.schema.PointConfig.Y","title":"<code>Y</code>  <code>instance-attribute</code>","text":"<p>Column to be treated as latitude/Y coordinate</p>"},{"location":"extensions/point/schema/#core.point.schema.PointConfig.Z","title":"<code>Z = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Column to be treated as altitude/Z coordinate</p>"},{"location":"extensions/point/schema/#core.point.schema.PointConfig.T","title":"<code>T = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Column to be treated as time coordinate</p>"},{"location":"extensions/point/schema/#core.point.schema.PointConfig.date_format","title":"<code>date_format = 'ISO8601'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Format to parse dates - will be used if T column is provided</p>"},{"location":"extensions/point/schema/#core.point.schema.PointConfig.epsg","title":"<code>epsg = 4326</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EPSG code</p>"},{"location":"extensions/raster/generator/","title":"Generator","text":""},{"location":"extensions/raster/generator/#core.raster.generator.RasterGenerator","title":"<code>RasterGenerator</code>","text":"<p>               Bases: <code>ItemGenerator[RasterConfig]</code></p> <p>Raster Generator</p>"},{"location":"extensions/raster/generator/#core.raster.generator.RasterGenerator.create_item_from_config","title":"<code>create_item_from_config(source_config)</code>","text":"<p>Generate Raster Item from config</p> <p>Parameters:</p> Name Type Description Default <code>source_config</code> <code>RasterConfig</code> <p>raster config - must contain band info</p> required <p>Returns:</p> Type Description <code>pystac.Item</code> <p>generated item</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if epsg code is provided in config but does not match that extracted from the asset</p>"},{"location":"extensions/raster/schema/","title":"Schema","text":""},{"location":"extensions/raster/schema/#core.raster.schema.BandInfo","title":"<code>BandInfo</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Band information for raster data</p>"},{"location":"extensions/raster/schema/#core.raster.schema.RasterConfig","title":"<code>RasterConfig</code>","text":"<p>               Bases: <code>SourceConfig</code></p> <p>Configuration for raster data sources</p>"},{"location":"extensions/raster/schema/#core.raster.schema.RasterConfig.band_info","title":"<code>band_info</code>  <code>instance-attribute</code>","text":"<p>List of band information - REQUIRED</p>"},{"location":"extensions/raster/schema/#core.raster.schema.RasterConfig.epsg","title":"<code>epsg = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EPSG code for the raster's coordinate reference system</p>"},{"location":"extensions/vector/generator/","title":"Generator","text":""},{"location":"extensions/vector/generator/#core.vector.generator.VectorGenerator","title":"<code>VectorGenerator</code>","text":"<p>               Bases: <code>BaseVectorGenerator[VectorConfig]</code></p> <p>ItemGenerator class that handles vector data with common vector formats - i.e (shp, zipped shp, gpkg, geojson)</p>"},{"location":"extensions/vector/generator/#core.vector.generator.VectorGenerator.create_item_from_config","title":"<code>create_item_from_config(source_config)</code>","text":"<p>Create item from vector config</p> <p>Parameters:</p> Name Type Description Default <code>source_config</code> <code>VectorConfig</code> <p>config information</p> required <p>Returns:</p> Type Description <code>pystac.Item</code> <p>stac metadata of the file described by source_config</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if config epsg information is different from epsg information from vector file</p>"},{"location":"extensions/vector/generator/#core.vector.generator.extract_epsg","title":"<code>extract_epsg(crs)</code>","text":"<p>Extract epsg information from crs object. If epsg info can be extracted directly from crs, return that value. Otherwise, try to convert the crs info to WKT2 and extract EPSG using regex</p> <p>Note that this method may yield unreliable result</p> <p>Parameters:</p> Name Type Description Default <code>crs</code> <code>CRS</code> <p>crs object</p> required <p>Returns:</p> Type Description <code>tuple[int, bool] - epsg code and reliability flag</code> <p>epsg information</p>"},{"location":"extensions/vector/schema/","title":"Schema","text":""},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig","title":"<code>VectorConfig</code>","text":"<p>               Bases: <code>SourceConfig</code>, <code>HasColumnInfo</code></p> <p>Extended source config with EPSG code.</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig.epsg","title":"<code>epsg = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EPSG code for checking against EPSG code of the vector data</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig.layer","title":"<code>layer = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vector layer for multi-layer shapefile</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig.join_file","title":"<code>join_file = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of join csv file</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig.join_attribute_vector","title":"<code>join_attribute_vector = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Attribute of shapefile to join with text file</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig.join_field","title":"<code>join_field = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Field from text file to join with vector file</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig.date_format","title":"<code>date_format = 'ISO8601'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Date format of text file</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig.join_T_column","title":"<code>join_T_column = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Time column of text file if any</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig.join_column_info","title":"<code>join_column_info = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of attributes associated with point/vector data</p>"},{"location":"extensions/vector/schema/#core.vector.schema.VectorConfig.coerce_to_object_text","title":"<code>coerce_to_object_text(v)</code>  <code>classmethod</code>","text":"<p>Convert json serialised string of column info into matched object</p>"},{"location":"metadata_examples/point/","title":"Point","text":""},{"location":"metadata_examples/point/#ozbarley-point-data","title":"OZBarley Point Data","text":"<p>OZBarley contains 2 point assets - <code>OZBarley1_measurement</code> and <code>OZBarley2_measurement</code>. The point asset can be downloaded from the following link: OZBarley1, OZBarley2. The overall config can be downloaded here. Note that the <code>epsg</code> code is known beforehand.</p>"},{"location":"metadata_examples/point/#llaracampey-point-data","title":"LlaraCampey Point Data","text":"<p>The simplified test case for Llara Campey contains <code>soil_data.csv</code> point data. The config can be downloaded here. The asset itself can be downloaded by visiting the <code>location</code> reference under <code>soil_measurement</code> entry. The link is reproduced here for convenience.</p>"},{"location":"metadata_examples/raster/","title":"Raster","text":""},{"location":"metadata_examples/raster/#ozbarley-raster-data","title":"OZBarley Raster Data","text":"<p>OZBarley contains 6 orthomosaics covering 2 areas over 3 time periods. The dataset also contains 2 DSM tifs. The config can be downloaded here. The actual assets can be downloaded by following the <code>location</code> field in corresponding entry in the config file. Please note how the <code>band_info</code> field is used to describe the raster bands.</p>"},{"location":"metadata_examples/raster/#llaracampey-raster-data","title":"LlaraCampey Raster Data","text":"<p>Llara Campey contains 4 tifs of krigged ECa and Gamma K measurements. The config can be downloaded here. The actual assets can be downloaded by following the <code>location</code> field in the corresponding entry. Please note how the <code>band_info</code> field is used to describe the raster bands.</p>"},{"location":"metadata_examples/vector/","title":"Vector","text":""},{"location":"metadata_examples/vector/#ozbarley-vector-data","title":"OZBarley Vector Data","text":"<p>OZBarley contains 2 vector assets - <code>OZBarley1_layout</code> and <code>OZBarley2_layout</code>. The overall config can be downloaded here. The vector assets can be downloaded by following the <code>location</code> field under <code>OZBarley1_layout</code> and <code>OZBarley2_layout</code> items in the config. The links for OZBarley1 and OZBarley2 are reproduced for convenience.</p>"},{"location":"metadata_examples/vector/#llaracampey-vector-data","title":"LlaraCampey Vector Data","text":"<p>The simplified test case for Llara Campey contains the boundary shapes of different Llara and Campey plots stored as shp file in a compressed zip. To specify a particular boundary, a layer field must be provided. For more information, please refer to the config. Note how C1, C2, ... layout files all reference the same zip, with <code>layer</code> being the differentiator. Also note that while OZBarley vector files have associated attributes that are described with <code>column_info</code>, the vector files for LlaraCampey are simple shape files with no attribute (and thus do not contain <code>column_info</code>).</p>"}]}